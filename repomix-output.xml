This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.eslintignore
.gitattributes
.github/copilot-instructions.md
.gitignore
.prettierignore
.prettierrc
eslint.config.js
index.html
package.json
pnpm-workspace.yaml
src/app/events.ts
src/app/loop.ts
src/app/main.ts
src/app/preloader.ts
src/app/state.ts
src/audio/index.ts
src/audio/scheduler.ts
src/audio/sfx.ts
src/cli/index.ts
src/cli/simulate.ts
src/input/contracts.ts
src/input/index.ts
src/input/input-manager.ts
src/input/launch-manager.ts
src/physics/ball-attachment.ts
src/physics/ball-launch.ts
src/physics/contracts.ts
src/physics/index.ts
src/physics/world.ts
src/render/contracts.ts
src/render/debug-overlay.ts
src/render/hud.ts
src/render/index.ts
src/render/paddle-body.ts
src/render/paddle-constraints.ts
src/render/stage.ts
src/types/index.ts
src/types/input.ts
src/util/geometry.ts
src/util/index.ts
src/util/input-helpers.ts
src/util/levels.ts
src/util/log.ts
src/util/paddle-reflection.ts
src/util/power-ups.ts
src/util/scoring.ts
src/util/speed-regulation.ts
tests/integration/paddle-ball-flow.spec.ts
tests/setup/vitest.setup.ts
tests/unit/app/loop.spec.ts
tests/unit/app/preloader.spec.ts
tests/unit/app/state.spec.ts
tests/unit/audio/mocks.ts
tests/unit/audio/sfx.spec.ts
tests/unit/bootstrap.spec.ts
tests/unit/cli/simulate.spec.ts
tests/unit/input/contracts.spec.ts
tests/unit/input/input-normalization.spec.ts
tests/unit/input/launch-detection.spec.ts
tests/unit/physics/ball-attachment.spec.ts
tests/unit/physics/ball-launch.spec.ts
tests/unit/physics/contracts.spec.ts
tests/unit/physics/world.spec.ts
tests/unit/render/contracts.spec.ts
tests/unit/render/hud.spec.ts
tests/unit/render/paddle-constraints.spec.ts
tests/unit/render/paddle-positioning.spec.ts
tests/unit/render/stage.spec.ts
tests/unit/util/paddle-reflection.spec.ts
tests/unit/util/scoring.spec.ts
tests/unit/util/speed-regulation.spec.ts
tsconfig.json
vite.config.ts
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".eslintignore">
node_modules/
dist/
build/
coverage/
*.min.js
</file>

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path=".prettierignore">
dist/
node_modules/
coverage/
build/
package-lock.json
yarn.lock
pnpm-lock.yaml
</file>

<file path=".prettierrc">
{
  "singleQuote": true,
  "semi": true,
  "trailingComma": "all",
  "printWidth": 100
}
</file>

<file path="eslint.config.js">
import { fileURLToPath } from 'node:url';
import tseslint from 'typescript-eslint';
import eslintPluginImport from 'eslint-plugin-import';
import prettierConfig from 'eslint-config-prettier';

const tsconfigRootDir = fileURLToPath(new URL('.', import.meta.url));
const tsFilePatterns = ['src/**/*.{ts,tsx}', 'tests/**/*.{ts,tsx}', '**/*.config.ts'];
const prettierRecommendedRules = prettierConfig?.configs?.recommended?.rules ?? {};

export default tseslint.config(
  {
    ignores: ['dist/**', 'coverage/**', 'node_modules/**'],
  },
  ...tseslint.configs.recommendedTypeChecked,
  ...tseslint.configs.stylisticTypeChecked,
  {
    files: tsFilePatterns,
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.json'],
        tsconfigRootDir,
      },
    },
    plugins: {
      import: eslintPluginImport,
    },
    settings: {
      'import/resolver': {
        typescript: true,
      },
    },
    rules: {
      ...eslintPluginImport.configs.recommended.rules,
      ...(eslintPluginImport.configs.typescript?.rules ?? {}),
      ...prettierRecommendedRules,
      '@typescript-eslint/no-floating-promises': 'error',
      '@typescript-eslint/require-await': 'error',
      'import/no-default-export': 'error',
    },
  },
  {
    files: ['**/*.config.{ts,js,mjs,cjs}'],
    rules: {
      'import/no-default-export': 'off',
    },
  },
);
</file>

<file path="pnpm-workspace.yaml">
packages:
  - .
</file>

<file path="src/app/loop.ts">
import type { PhysicsWorldHandle } from '@physics/world';
import type { StageHandle } from '@render/stage';

let fallbackHandle = 1;
const fallbackTimers = new Map<number, ReturnType<typeof setTimeout>>();

const FALLBACK_REQUEST = (callback: FrameRequestCallback): number => {
    const handle = fallbackHandle++;
    const timer = setTimeout(() => {
        fallbackTimers.delete(handle);
        callback(Date.now());
    }, DEFAULT_STEP_MS);
    fallbackTimers.set(handle, timer);
    return handle;
};

const FALLBACK_CANCEL = (handle: number): void => {
    const timer = fallbackTimers.get(handle);
    if (timer) {
        clearTimeout(timer);
        fallbackTimers.delete(handle);
    }
};

const resolveNow = (): (() => number) => {
    if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
        return () => performance.now();
    }

    return () => Date.now();
};

export const DEFAULT_STEP_MS = 1000 / 120;
const DEFAULT_MAX_STEPS = 5;

export interface LoopHooks {
    readonly beforeStep?: (deltaMs: number) => void;
    readonly afterStep?: (deltaMs: number) => void;
    readonly beforeRender?: (interpolation: number) => void;
    readonly afterRender?: () => void;
}

type PhysicsStepper = Pick<PhysicsWorldHandle, 'step'>;
type StageRenderer = Pick<StageHandle, 'app'>;

export interface GameLoopOptions {
    readonly world: PhysicsStepper;
    readonly stage: StageRenderer;
    readonly hooks?: LoopHooks;
    readonly stepMs?: number;
    readonly maxStepsPerFrame?: number;
    readonly now?: () => number;
    readonly requestFrame?: (callback: FrameRequestCallback) => number;
    readonly cancelFrame?: (handle: number) => void;
}

export interface GameLoopController {
    readonly start: () => void;
    readonly stop: () => void;
    readonly isRunning: () => boolean;
}

export const createGameLoop = (options: GameLoopOptions): GameLoopController => {
    const stepMs = options.stepMs ?? DEFAULT_STEP_MS;
    const maxStepsPerFrame = Math.max(1, options.maxStepsPerFrame ?? DEFAULT_MAX_STEPS);
    const now = options.now ?? resolveNow();
    const requestFrame = options.requestFrame ?? (typeof requestAnimationFrame === 'function' ? requestAnimationFrame : FALLBACK_REQUEST);
    const cancelFrame = options.cancelFrame ?? (typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : FALLBACK_CANCEL);

    const hooks = options.hooks ?? {};
    const physics = options.world;
    const stage = options.stage;

    let running = false;
    let accumulator = 0;
    let lastTime = 0;
    let frameHandle: number | undefined;

    const maxDeltaMs = stepMs * maxStepsPerFrame;

    const scheduleNext = () => {
        frameHandle = requestFrame(tick);
    };

    const tick: FrameRequestCallback = () => {
        if (!running) {
            return;
        }

        const currentTime = now();
        let deltaMs = currentTime - lastTime;
        lastTime = currentTime;
        if (deltaMs < 0) {
            deltaMs = 0;
        }
        if (deltaMs > maxDeltaMs) {
            deltaMs = maxDeltaMs;
        }

        accumulator += deltaMs;

        let steps = 0;
        while (accumulator >= stepMs && steps < maxStepsPerFrame) {
            hooks.beforeStep?.(stepMs);
            physics.step(stepMs);
            hooks.afterStep?.(stepMs);
            accumulator -= stepMs;
            steps += 1;
        }

        const interpolation = accumulator / stepMs;
        hooks.beforeRender?.(interpolation);
        stage.app.render();
        hooks.afterRender?.();

        scheduleNext();
    };

    const start = () => {
        if (running) {
            return;
        }

        running = true;
        accumulator = 0;
        lastTime = now();
        scheduleNext();
    };

    const stop = () => {
        if (!running) {
            return;
        }

        running = false;
        if (frameHandle !== undefined) {
            cancelFrame(frameHandle);
            frameHandle = undefined;
        }
    };

    const isRunning = () => running;

    return {
        start,
        stop,
        isRunning,
    };
};
</file>

<file path="src/audio/scheduler.ts">
import { Transport, now as toneNow } from 'tone';

export interface ScheduledEventHandle {
    readonly id: number;
    readonly time: number;
}

export interface ToneSchedulerOptions {
    readonly lookAheadMs?: number;
    readonly now?: () => number;
    readonly schedule?: (callback: (time: number) => void, at: number) => number;
    readonly clear?: (id: number) => void;
    readonly cancel?: (time?: number) => void;
}

export interface ToneScheduler {
    readonly lookAheadMs: number;
    readonly schedule: (callback: (time: number) => void, offsetMs?: number) => ScheduledEventHandle;
    readonly cancel: (handle: ScheduledEventHandle) => void;
    readonly dispose: () => void;
}

const toSeconds = (milliseconds: number): number => milliseconds / 1000;

export const createToneScheduler = (options: ToneSchedulerOptions = {}): ToneScheduler => {
    const lookAheadMs = Math.max(0, options.lookAheadMs ?? 120);
    const now = options.now ?? toneNow;
    const scheduleFn = options.schedule ?? ((callback, at) => Transport.scheduleOnce(callback, at));
    const clearFn = options.clear ?? ((id) => Transport.clear(id));
    const cancelFn = options.cancel ?? ((time = 0) => Transport.cancel(time));

    const active = new Set<number>();

    const schedule: ToneScheduler['schedule'] = (callback, offsetMs = 0) => {
        const targetTime = now() + toSeconds(lookAheadMs + offsetMs);
        const id = scheduleFn((scheduledTime) => {
            active.delete(id);
            callback(scheduledTime);
        }, targetTime);
        active.add(id);
        return { id, time: targetTime };
    };

    const cancel: ToneScheduler['cancel'] = (handle) => {
        if (active.has(handle.id)) {
            active.delete(handle.id);
            clearFn(handle.id);
        }
    };

    const dispose: ToneScheduler['dispose'] = () => {
        for (const id of active) {
            clearFn(id);
        }
        active.clear();
        cancelFn(0);
    };

    return {
        lookAheadMs,
        schedule,
        cancel,
        dispose,
    };
};
</file>

<file path="src/audio/sfx.ts">
import type { LuckyBreakEventBus, EventEnvelope, BrickBreakPayload } from '@app/events';
import type { ScheduledEventHandle, ToneScheduler } from './scheduler';

export interface SfxTriggerDescriptor {
    readonly id: string;
    readonly time: number;
    readonly gain: number;
    readonly detune: number;
    readonly pan: number;
    readonly source: {
        readonly event: 'BrickBreak';
        readonly row: number;
        readonly velocity: number;
    };
}

export interface SfxRouterOptions {
    readonly bus: LuckyBreakEventBus;
    readonly scheduler: ToneScheduler;
    readonly trigger?: (descriptor: SfxTriggerDescriptor) => void;
    readonly brickSampleId?: string;
}

export interface SfxRouter {
    readonly dispose: () => void;
}

const clamp = (value: number, min: number, max: number): number => Math.max(min, Math.min(max, value));

const defaultTrigger = (_descriptor: SfxTriggerDescriptor): void => {
    // Intentionally blank: production wiring occurs in audio bootstrap.
};

const normalizePan = (column: number): number => {
    const normalized = (column - 5.5) / 5.5;
    return clamp(Number(normalized.toFixed(2)), -1, 1);
};

const calculateGain = (velocity: number): number => {
    const base = 0.55 + velocity / 20;
    return Number(clamp(base, 0.4, 1).toFixed(2));
};

const calculateDetune = (comboHeat: number, row: number): number => {
    const detune = (comboHeat - 5) * 6 + (row - 3) * 4;
    return Math.round(detune);
};

const createBrickTrigger = (
    payload: BrickBreakPayload,
    time: number,
    sampleId: string,
): SfxTriggerDescriptor => ({
    id: sampleId,
    time,
    gain: calculateGain(payload.velocity),
    detune: calculateDetune(payload.comboHeat, payload.row),
    pan: normalizePan(payload.col),
    source: {
        event: 'BrickBreak',
        row: payload.row,
        velocity: payload.velocity,
    },
});

export const createSfxRouter = (options: SfxRouterOptions): SfxRouter => {
    const trigger = options.trigger ?? defaultTrigger;
    const sampleId = options.brickSampleId ?? 'brick/snare-01';

    const pending = new Set<ScheduledEventHandle>();

    const handleBrickBreak = (event: EventEnvelope<'BrickBreak'>) => {
        const handle = options.scheduler.schedule((scheduledTime) => {
            pending.delete(handle);
            trigger(createBrickTrigger(event.payload, scheduledTime, sampleId));
        });
        pending.add(handle);
    };

    const subscriptions: Array<() => void> = [
        options.bus.subscribe('BrickBreak', handleBrickBreak),
    ];

    const dispose: SfxRouter['dispose'] = () => {
        for (const unsubscribe of subscriptions) {
            unsubscribe();
        }
        subscriptions.length = 0;

        for (const handle of pending) {
            options.scheduler.cancel(handle);
        }
        pending.clear();
    };

    return {
        dispose,
    };
};
</file>

<file path="src/cli/simulate.ts">
import { createEventBus, type EventEnvelope, type LuckyBreakEventBus, type LuckyBreakEventName } from '@app/events';
import { createGameSessionManager } from '@app/state';

export interface SimulateCommandIO {
    readonly readStdin: () => Promise<string>;
    readonly writeStdout: (output: string) => Promise<void>;
    readonly writeStderr?: (message: string) => Promise<void> | void;
}

export interface SimulationOptions {
    readonly audio?: boolean;
    readonly visual?: boolean;
    readonly telemetry?: boolean;
}

export interface SimulationInput {
    readonly mode: 'simulate';
    readonly seed?: number;
    readonly round?: number;
    readonly durationSec?: number;
    readonly options?: SimulationOptions;
}

export interface SimulationResult {
    readonly ok: true;
    readonly sessionId: string;
    readonly score: number;
    readonly events: number;
    readonly volleyStats: {
        readonly longestVolley: number;
        readonly averageSpeed: number;
    };
    readonly durationMs: number;
}

interface SimulationMetrics {
    longestVolley: number;
    currentVolley: number;
    speedTotal: number;
}

const DEFAULT_SEED = 1;
const DEFAULT_ROUND = 1;
const DEFAULT_DURATION_SEC = 180;
const DEFAULT_BRICK_TOTAL = 18;
const BRICK_TYPES = ['standard', 'multi-hit', 'power-up'] as const;

const createSeededRandom = (seed: number): (() => number) => {
    let state = (seed >>> 0) || 1;
    return () => {
        state = (state * 1664525 + 1013904223) >>> 0;
        return state / 0x100000000;
    };
};

const captureEvents = (eventNames: readonly LuckyBreakEventName[]) => {
    const events: EventEnvelope<LuckyBreakEventName>[] = [];
    return {
        events,
        attach(bus: LuckyBreakEventBus) {
            for (const name of eventNames) {
                bus.subscribe(name, (event) => {
                    events.push(event);
                });
            }
        },
    };
};

const updateMetrics = (metrics: SimulationMetrics, velocity: number) => {
    metrics.currentVolley += 1;
    if (metrics.currentVolley > metrics.longestVolley) {
        metrics.longestVolley = metrics.currentVolley;
    }
    metrics.speedTotal += velocity;
};

const finalizeMetrics = (metrics: SimulationMetrics, brickCount: number) => {
    const averageSpeed = brickCount > 0 ? metrics.speedTotal / brickCount : 0;
    return {
        longestVolley: metrics.longestVolley,
        averageSpeed: Number(averageSpeed.toFixed(2)),
    };
};

export const runHeadlessSimulation = async (input: SimulationInput): Promise<SimulationResult> => {
    const seed = typeof input.seed === 'number' ? input.seed : DEFAULT_SEED;
    const round = typeof input.round === 'number' ? input.round : DEFAULT_ROUND;
    const durationSec = typeof input.durationSec === 'number' ? Math.max(1, input.durationSec) : DEFAULT_DURATION_SEC;
    const sessionId = `sim-${seed}-r${round}`;
    const rng = createSeededRandom(seed + round);

    const breakableBricks = DEFAULT_BRICK_TOTAL + Math.floor(rng() * 12);
    const durationMs = durationSec * 1000;
    const stepMs = durationMs / Math.max(1, breakableBricks);

    let currentTime = 0;
    const bus = createEventBus();
    const collector = captureEvents(['BrickBreak', 'RoundCompleted']);
    collector.attach(bus);

    const manager = createGameSessionManager({
        sessionId,
        now: () => currentTime,
        eventBus: bus,
    });

    manager.startRound({ breakableBricks });

    const metrics: SimulationMetrics = {
        longestVolley: 0,
        currentVolley: 0,
        speedTotal: 0,
    };

    for (let index = 0; index < breakableBricks; index += 1) {
        currentTime += stepMs;
        const velocity = 6 + rng() * 6;
        const points = 100 + Math.round(rng() * 200);
        const row = Math.floor(rng() * 8);
        const col = Math.floor(rng() * 12);
        const brickType = BRICK_TYPES[Math.floor(rng() * BRICK_TYPES.length)];

        manager.recordBrickBreak({
            points,
            event: {
                row,
                col,
                velocity,
                brickType,
            },
        });

        updateMetrics(metrics, velocity);
    }

    currentTime = durationMs;
    manager.completeRound();

    const snapshot = manager.snapshot();
    const volleyStats = finalizeMetrics(metrics, breakableBricks);

    return {
        ok: true,
        sessionId,
        score: snapshot.score,
        events: collector.events.length,
        volleyStats,
        durationMs,
    };
};

const logToStderr = async (io: SimulateCommandIO, message: string) => {
    if (io.writeStderr) {
        await io.writeStderr(message);
    }
};

export interface SimulateCommand {
    readonly execute: () => Promise<number>;
}

export const createSimulateCommand = (io: SimulateCommandIO): SimulateCommand => {
    const execute = async (): Promise<number> => {
        let raw: string;

        try {
            raw = await io.readStdin();
        } catch (error) {
            await logToStderr(io, `Failed to read simulation input: ${(error as Error).message}`);
            return 1;
        }

        let parsed: SimulationInput;
        try {
            parsed = JSON.parse(raw) as SimulationInput;
        } catch (error) {
            await logToStderr(io, 'Failed to read simulation input: invalid JSON payload');
            return 1;
        }

        if (!parsed || parsed.mode !== 'simulate') {
            await logToStderr(io, 'Simulation command requires a payload with "mode": "simulate".');
            return 1;
        }

        await logToStderr(io, `Running simulate command for session seed ${parsed.seed ?? DEFAULT_SEED}.`);

        const result = await runHeadlessSimulation(parsed);
        await io.writeStdout(JSON.stringify(result));

        return 0;
    };

    return {
        execute,
    };
};
</file>

<file path="src/input/contracts.ts">
/**
 * Input System Contract
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Defines the public interface for input handling and paddle control
 */

export interface InputManager {
    /**
     * Initialize input handling for the given container
     * @param container - DOM element to attach input listeners to
     */
    initialize(container: HTMLElement): void;

    /**
     * Get the current target position for paddle movement
     * @returns Target position in game coordinates, or null if no input
     */
    getPaddleTarget(): Vector2 | null;

    /**
     * Check if a launch should be triggered
     * @returns True if launch conditions are met
     */
    shouldLaunch(): boolean;

    /**
     * Reset launch trigger state after processing
     */
    resetLaunchTrigger(): void;

    /**
     * Get current input state for debugging
     */
    getDebugState(): InputDebugState;

    /**
     * Clean up input listeners
     */
    destroy(): void;
}

export interface InputDebugState {
    activeInputs: readonly InputType[];
    mousePosition: Vector2 | null;
    keyboardPressed: readonly string[];
    paddleTarget: Vector2 | null;
    launchPending: boolean;
}

export type InputType = 'mouse' | 'keyboard' | 'touch';

export interface Vector2 {
    x: number;
    y: number;
}
</file>

<file path="src/input/index.ts">
/**
 * Input handling module for paddle control and ball launch mechanics
 *
 * This module provides cross-platform input handling for mouse, keyboard, and touch
 * interactions, including paddle movement and launch trigger detection.
 */

// Export types and interfaces
export type { InputManager, InputDebugState, InputType, Vector2 } from './contracts';

// Export implementations
export { GameInputManager } from './input-manager';
export { PaddleLaunchManager } from './launch-manager';
</file>

<file path="src/input/launch-manager.ts">
/**
 * Launch Manager
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Detects launch triggers from paddle movement or screen taps
 */

import type { Vector2 } from '../types';

export interface LaunchTrigger {
    type: 'movement' | 'tap';
    position: Vector2;
    timestamp: number;
}

export interface LaunchManager {
    /**
     * Check if a launch should be triggered
     * @param currentPosition - Current paddle position
     * @param previousPosition - Previous paddle position
     * @param movementThreshold - Minimum movement to trigger launch
     * @returns True if launch conditions are met
     */
    shouldTriggerLaunch(
        currentPosition: Vector2,
        previousPosition: Vector2 | null,
        movementThreshold: number
    ): boolean;

    /**
     * Record a tap/click launch trigger
     * @param position - Position of the tap/click
     */
    triggerTapLaunch(position: Vector2): void;

    /**
     * Check if launch is pending
     * @returns True if launch is pending
     */
    isLaunchPending(): boolean;

    /**
     * Consume the launch trigger (reset to not pending)
     */
    consumeLaunchTrigger(): LaunchTrigger | null;

    /**
     * Reset launch state
     */
    reset(): void;

    /**
     * Get debug information
     */
    getDebugInfo(): LaunchDebugInfo;
}

export interface LaunchDebugInfo {
    launchPending: boolean;
    lastTrigger?: LaunchTrigger;
    movementThreshold: number;
}

export class PaddleLaunchManager implements LaunchManager {
    private launchPending = false;
    private lastTrigger: LaunchTrigger | null = null;
    private readonly movementThreshold: number;

    constructor(movementThreshold = 5) {
        this.movementThreshold = movementThreshold;
    }

    shouldTriggerLaunch(
        currentPosition: Vector2,
        previousPosition: Vector2 | null,
        movementThreshold: number
    ): boolean {
        if (!previousPosition) {
            return false;
        }

        const deltaX = Math.abs(currentPosition.x - previousPosition.x);
        const deltaY = Math.abs(currentPosition.y - previousPosition.y);
        const movement = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

        if (movement > movementThreshold) {
            this.launchPending = true;
            this.lastTrigger = {
                type: 'movement',
                position: { ...currentPosition },
                timestamp: Date.now(),
            };
            return true;
        }

        return false;
    }

    triggerTapLaunch(position: Vector2): void {
        this.launchPending = true;
        this.lastTrigger = {
            type: 'tap',
            position: { ...position },
            timestamp: Date.now(),
        };
    }

    isLaunchPending(): boolean {
        return this.launchPending;
    }

    consumeLaunchTrigger(): LaunchTrigger | null {
        if (this.launchPending && this.lastTrigger) {
            const trigger = this.lastTrigger;
            this.launchPending = false;
            this.lastTrigger = null;
            return trigger;
        }
        return null;
    }

    reset(): void {
        this.launchPending = false;
        this.lastTrigger = null;
    }

    getDebugInfo(): LaunchDebugInfo {
        return {
            launchPending: this.launchPending,
            lastTrigger: this.lastTrigger || undefined,
            movementThreshold: this.movementThreshold,
        };
    }
}
</file>

<file path="src/physics/ball-attachment.ts">
/**
 * Ball Attachment Controller
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Implements ball attachment mechanics for paddle control
 */

import type { BallController, Ball, BallOptions, Vector2, BallDebugInfo } from './contracts';
import { createPhysicsWorld } from './world';

export class BallAttachmentController implements BallController {
    private physicsWorld = createPhysicsWorld();

    /**
     * Create a new ball attached to the paddle
     */
    createAttachedBall(paddlePosition: Vector2, options: BallOptions = {}): Ball {
        const radius = options.radius ?? 8;
        const attachmentOffset = { x: 0, y: -radius - 10 }; // Position ball above paddle

        const physicsBody = this.physicsWorld.factory.ball({
            position: {
                x: paddlePosition.x + attachmentOffset.x,
                y: paddlePosition.y + attachmentOffset.y,
            },
            radius,
            restitution: options.restitution ?? 0.98,
        });

        // Create a temporary paddle body for attachment
        const tempPaddleBody = this.physicsWorld.factory.paddle({
            position: paddlePosition,
            size: { width: 100, height: 20 },
        });

        // Attach the ball to the temporary paddle
        this.physicsWorld.attachBallToPaddle(physicsBody, tempPaddleBody, attachmentOffset);

        return {
            id: `ball-${Date.now()}`,
            physicsBody,
            isAttached: true,
            attachmentOffset,
            radius,
        };
    }

    /**
     * Update ball position to stay attached to paddle
     */
    updateAttachment(ball: Ball, paddlePosition: Vector2): void {
        if (ball.isAttached) {
            this.physicsWorld.updateBallAttachment(ball.physicsBody, paddlePosition);
        }
    }

    /**
     * Launch the ball with upward velocity
     */
    launchBall(ball: Ball, direction: Vector2 = { x: 0, y: -1 }): void {
        if (ball.isAttached) {
            this.physicsWorld.detachBallFromPaddle(ball.physicsBody);
            ball.isAttached = false;
        }

        // Normalize direction and apply velocity
        const speed = 300; // Launch speed
        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y);
        const normalizedDirection = length > 0 ? {
            x: direction.x / length,
            y: direction.y / length,
        } : { x: 0, y: -1 };

        ball.physicsBody.velocity.x = normalizedDirection.x * speed;
        ball.physicsBody.velocity.y = normalizedDirection.y * speed;
    }

    /**
     * Check if ball is currently attached to paddle
     */
    isAttached(ball: Ball): boolean {
        return this.physicsWorld.isBallAttached(ball.physicsBody);
    }

    /**
     * Reset ball to attached state
     */
    resetToAttached(ball: Ball, paddlePosition: Vector2): void {
        // Create a temporary paddle body for attachment
        const tempPaddleBody = this.physicsWorld.factory.paddle({
            position: paddlePosition,
            size: { width: 100, height: 20 },
        });

        this.physicsWorld.attachBallToPaddle(ball.physicsBody, tempPaddleBody, ball.attachmentOffset);
        ball.isAttached = true;
    }

    /**
     * Get ball debug information
     */
    getDebugInfo(ball: Ball): BallDebugInfo {
        const attachment = this.physicsWorld.getBallAttachment(ball.physicsBody);
        return {
            position: ball.physicsBody.position,
            velocity: ball.physicsBody.velocity,
            isAttached: ball.isAttached,
            attachmentOffset: ball.attachmentOffset,
            physicsBodyId: ball.physicsBody.id,
        };
    }
}
</file>

<file path="src/physics/contracts.ts">
/**
 * Ball Physics Contract
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Defines the ball physics interface for attachment and launch mechanics
 */

export interface BallController {
    /**
     * Create a new ball attached to the paddle
     * @param paddlePosition - Current paddle center position
     * @param options - Ball configuration options
     * @returns Ball instance ready for attachment
     */
    createAttachedBall(paddlePosition: Vector2, options?: BallOptions): Ball;

    /**
     * Update ball position to stay attached to paddle
     * @param ball - Ball to update
     * @param paddlePosition - Current paddle center position
     */
    updateAttachment(ball: Ball, paddlePosition: Vector2): void;

    /**
     * Launch the ball with upward velocity
     * @param ball - Ball to launch
     * @param direction - Optional launch direction (default: upward)
     */
    launchBall(ball: Ball, direction?: Vector2): void;

    /**
     * Check if ball is currently attached to paddle
     * @param ball - Ball to check
     * @returns True if ball is attached
     */
    isAttached(ball: Ball): boolean;

    /**
     * Reset ball to attached state
     * @param ball - Ball to reset
     * @param paddlePosition - Paddle position for attachment
     */
    resetToAttached(ball: Ball, paddlePosition: Vector2): void;

    /**
     * Get ball debug information
     * @param ball - Ball to inspect
     */
    getDebugInfo(ball: Ball): BallDebugInfo;
}

export interface Ball {
    id: string;
    physicsBody: any; // Matter.js Body
    isAttached: boolean;
    attachmentOffset: Vector2;
    radius: number;
}

export interface BallOptions {
    radius?: number;
    restitution?: number;
    friction?: number;
}

export interface BallDebugInfo {
    position: Vector2;
    velocity: Vector2;
    isAttached: boolean;
    attachmentOffset: Vector2;
    physicsBodyId: number;
}

export interface Vector2 {
    x: number;
    y: number;
}
</file>

<file path="src/physics/index.ts">
/**
 * Physics Module Exports
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Central export point for physics functionality
 */

export * from './contracts';
export * from './world';
export * from './ball-attachment';
export * from './ball-launch';
</file>

<file path="src/render/contracts.ts">
/**
 * Paddle Control Contract
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Defines the paddle control interface for movement and interaction
 */

export interface PaddleController {
    /**
     * Create a new paddle with physics body
     * @param initialPosition - Starting position for the paddle
     * @param options - Paddle configuration options
     * @returns Paddle instance ready for control
     */
    createPaddle(initialPosition: Vector2, options?: PaddleOptions): Paddle;

    /**
     * Update paddle position based on input
     * @param paddle - Paddle to update
     * @param deltaTime - Time elapsed since last update
     * @param inputState - Current input state
     */
    updatePaddle(paddle: Paddle, deltaTime: number, inputState: InputState): void;

    /**
     * Set paddle position directly (for initialization or reset)
     * @param paddle - Paddle to position
     * @param position - New position
     */
    setPaddlePosition(paddle: Paddle, position: Vector2): void;

    /**
     * Get paddle bounds for collision detection
     * @param paddle - Paddle to query
     * @returns Bounding rectangle
     */
    getPaddleBounds(paddle: Paddle): Rectangle;

    /**
     * Get paddle center position
     * @param paddle - Paddle to query
     * @returns Center position
     */
    getPaddleCenter(paddle: Paddle): Vector2;

    /**
     * Check if paddle is at screen boundary
     * @param paddle - Paddle to check
     * @param screenWidth - Screen width
     * @returns Boundary collision info
     */
    checkBoundaryCollision(paddle: Paddle, screenWidth: number): BoundaryCollision;

    /**
     * Get paddle debug information
     * @param paddle - Paddle to inspect
     */
    getDebugInfo(paddle: Paddle): PaddleDebugInfo;
}

export interface Paddle {
    id: string;
    physicsBody: any; // Matter.js Body
    width: number;
    height: number;
    speed: number;
    position: Vector2;
}

export interface PaddleOptions {
    width?: number;
    height?: number;
    speed?: number;
    color?: number;
}

export interface InputState {
    leftPressed: boolean;
    rightPressed: boolean;
    mouseX?: number;
    touchX?: number;
    launchRequested: boolean;
}

export interface Rectangle {
    x: number;
    y: number;
    width: number;
    height: number;
}

export interface BoundaryCollision {
    left: boolean;
    right: boolean;
}

export interface PaddleDebugInfo {
    position: Vector2;
    velocity: Vector2;
    bounds: Rectangle;
    physicsBodyId: number;
    inputState: InputState;
}

export interface Vector2 {
    x: number;
    y: number;
}
</file>

<file path="src/render/hud.ts">
import type { GameSessionSnapshot, HudPromptSeverity } from '@app/state';

export interface HudScoreboardEntry {
    readonly id: 'score' | 'lives' | 'bricks' | 'momentum' | 'audio';
    readonly label: string;
    readonly value: string;
}

export interface HudScoreboardPrompt {
    readonly id: string;
    readonly severity: HudPromptSeverity;
    readonly message: string;
}

export interface HudScoreboardView {
    readonly statusText: string;
    readonly summaryLine: string;
    readonly entries: readonly HudScoreboardEntry[];
    readonly prompts: readonly HudScoreboardPrompt[];
}

type NumberFormatter = Intl.NumberFormat;

const SCORE_FORMATTER: NumberFormatter = new Intl.NumberFormat('en-US');

const capitalize = (value: string): string => value.charAt(0).toUpperCase() + value.slice(1);

const formatScore = (score: number): string => SCORE_FORMATTER.format(Math.max(0, Math.floor(score)));

const formatLives = (lives: number): string => {
    if (lives <= 0) {
        return '—';
    }

    return '❤'.repeat(Math.min(lives, 10));
};

const formatBrickProgress = (remaining: number, total: number): string => {
    if (total <= 0) {
        return `${remaining} / ${total} (0%)`;
    }

    const cleared = total - remaining;
    const percent = Math.round((cleared / total) * 100);
    return `${remaining} / ${total} (${percent}%)`;
};

const formatMomentum = (comboHeat: number, volleyLength: number): string => `Heat ${comboHeat} · Volley ${volleyLength}`;

const formatAudio = (muted: boolean, masterVolume: number): string => {
    if (muted || masterVolume <= 0) {
        return 'Muted';
    }

    const pct = Math.round(masterVolume * 100);
    return `Master ${pct}%`;
};

const formatSummary = (snapshot: GameSessionSnapshot): string => {
    const outcome = snapshot.lastOutcome;
    if (!outcome) {
        if (snapshot.status === 'active') {
            const elapsedSeconds = Math.floor(snapshot.elapsedTimeMs / 1000);
            return `Elapsed ${elapsedSeconds}s`;
        }
        return '';
    }

    const seconds = Math.max(0, Math.round(outcome.durationMs / 1000));
    if (outcome.result === 'win') {
        const scoreDelta = SCORE_FORMATTER.format(outcome.scoreAwarded);
        return `Win in ${seconds}s · Score +${scoreDelta}`;
    }

    return `Loss in ${seconds}s`;
};

const toPromptView = (snapshot: GameSessionSnapshot): readonly HudScoreboardPrompt[] =>
    snapshot.hud.prompts.map((prompt) => ({
        id: prompt.id,
        severity: prompt.severity,
        message: prompt.message,
    }));

export const buildHudScoreboard = (snapshot: GameSessionSnapshot): HudScoreboardView => {
    const statusText = `Round ${snapshot.hud.round} — ${capitalize(snapshot.status)}`;

    const entries: HudScoreboardEntry[] = [
        {
            id: 'score',
            label: 'Score',
            value: formatScore(snapshot.hud.score),
        },
        {
            id: 'lives',
            label: 'Lives',
            value: formatLives(snapshot.hud.lives),
        },
        {
            id: 'bricks',
            label: 'Bricks',
            value: formatBrickProgress(snapshot.hud.brickRemaining, snapshot.hud.brickTotal),
        },
        {
            id: 'momentum',
            label: 'Momentum',
            value: formatMomentum(snapshot.hud.momentum.comboHeat, snapshot.hud.momentum.volleyLength),
        },
        {
            id: 'audio',
            label: 'Audio',
            value: formatAudio(snapshot.preferences.muted, snapshot.preferences.masterVolume),
        },
    ];

    return {
        statusText,
        summaryLine: formatSummary(snapshot),
        entries,
        prompts: toPromptView(snapshot),
    };
};
</file>

<file path="src/render/index.ts">
/**
 * Render Module Exports
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Central export point for rendering functionality
 */

export * from './contracts';
export * from './stage';
export * from './hud';
export * from './debug-overlay';
</file>

<file path="src/render/paddle-constraints.ts">
/**
 * Paddle Boundary Constraints
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Implements boundary constraints for paddle movement
 */

import type { Vector2, Rectangle } from './contracts';

export interface BoundaryConstraints {
    /**
     * Constrain a position within the given bounds
     * @param position - Position to constrain
     * @param bounds - Boundary rectangle
     * @returns Constrained position
     */
    constrainToBounds(position: Vector2, bounds: Rectangle): Vector2;

    /**
     * Check if a position is within bounds
     * @param position - Position to check
     * @param bounds - Boundary rectangle
     * @returns True if position is within bounds
     */
    isWithinBounds(position: Vector2, bounds: Rectangle): boolean;

    /**
     * Get the distance to boundary in a given direction
     * @param position - Current position
     * @param direction - Direction vector (normalized)
     * @param bounds - Boundary rectangle
     * @returns Distance to boundary, or Infinity if no boundary in that direction
     */
    distanceToBoundary(position: Vector2, direction: Vector2, bounds: Rectangle): number;
}

export class PaddleBoundaryConstraints implements BoundaryConstraints {
    constrainToBounds(position: Vector2, bounds: Rectangle): Vector2 {
        const constrainedX = Math.max(
            bounds.x,
            Math.min(bounds.x + bounds.width, position.x)
        );

        const constrainedY = Math.max(
            bounds.y,
            Math.min(bounds.y + bounds.height, position.y)
        );

        return {
            x: constrainedX,
            y: constrainedY,
        };
    }

    isWithinBounds(position: Vector2, bounds: Rectangle): boolean {
        return position.x >= bounds.x &&
            position.x <= bounds.x + bounds.width &&
            position.y >= bounds.y &&
            position.y <= bounds.y + bounds.height;
    }

    distanceToBoundary(position: Vector2, direction: Vector2, bounds: Rectangle): number {
        // Normalize direction
        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y);
        if (length === 0) {
            return Infinity;
        }

        const normalizedDir = {
            x: direction.x / length,
            y: direction.y / length,
        };

        let minDistance = Infinity;

        // Check each boundary
        const boundaries = [
            // Left boundary
            normalizedDir.x < 0 ? (bounds.x - position.x) / normalizedDir.x : Infinity,
            // Right boundary
            normalizedDir.x > 0 ? ((bounds.x + bounds.width) - position.x) / normalizedDir.x : Infinity,
            // Top boundary
            normalizedDir.y < 0 ? (bounds.y - position.y) / normalizedDir.y : Infinity,
            // Bottom boundary
            normalizedDir.y > 0 ? ((bounds.y + bounds.height) - position.y) / normalizedDir.y : Infinity,
        ];

        for (const distance of boundaries) {
            if (distance > 0 && distance < minDistance) {
                minDistance = distance;
            }
        }

        return minDistance;
    }
}
</file>

<file path="src/types/index.ts">
/**
 * Types Module Exports
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Central export point for all type definitions
 */

export * from './input';
</file>

<file path="src/types/input.ts">
/**
 * Shared Type Definitions
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Common types used across input, physics, and render modules
 */

/**
 * 2D vector with x and y coordinates
 */
export interface Vector2 {
    x: number;
    y: number;
}

/**
 * Rectangle with position and dimensions
 */
export interface Rectangle {
    x: number;
    y: number;
    width: number;
    height: number;
}

/**
 * Input types supported by the game
 */
export type InputType = 'mouse' | 'keyboard' | 'touch';

/**
 * Normalized input state for paddle control
 */
export interface InputState {
    leftPressed: boolean;
    rightPressed: boolean;
    mouseX?: number;
    touchX?: number;
    launchRequested: boolean;
}

/**
 * Debug information for input system
 */
export interface InputDebugState {
    activeInputs: readonly InputType[];
    mousePosition: Vector2 | null;
    keyboardPressed: readonly string[];
    paddleTarget: Vector2 | null;
    launchPending: boolean;
}

/**
 * Physics body identifier
 */
export type PhysicsBodyId = number;

/**
 * Ball attachment state
 */
export interface BallAttachment {
    isAttached: boolean;
    attachmentOffset: Vector2;
    paddlePosition: Vector2;
}

/**
 * Ball launch configuration
 */
export interface BallLaunchConfig {
    initialVelocity: Vector2;
    launchDirection: Vector2;
    launchForce: number;
}

/**
 * Paddle movement constraints
 */
export interface PaddleConstraints {
    minX: number;
    maxX: number;
    speed: number;
}

/**
 * Boundary collision detection
 */
export interface BoundaryCollision {
    left: boolean;
    right: boolean;
}
</file>

<file path="src/util/geometry.ts">
/**
 * Geometry Utilities
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Utility functions for 2D geometry operations
 */

import type { Vector2, Rectangle } from '../types';

/**
 * Create a new Vector2
 */
export function createVector2(x: number = 0, y: number = 0): Vector2 {
    return { x, y };
}

/**
 * Add two vectors
 */
export function addVectors(a: Vector2, b: Vector2): Vector2 {
    return { x: a.x + b.x, y: a.y + b.y };
}

/**
 * Subtract vector b from vector a
 */
export function subtractVectors(a: Vector2, b: Vector2): Vector2 {
    return { x: a.x - b.x, y: a.y - b.y };
}

/**
 * Multiply vector by scalar
 */
export function multiplyVector(vector: Vector2, scalar: number): Vector2 {
    return { x: vector.x * scalar, y: vector.y * scalar };
}

/**
 * Calculate distance between two points
 */
export function distance(a: Vector2, b: Vector2): number {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
}

/**
 * Normalize a vector (make it unit length)
 */
export function normalizeVector(vector: Vector2): Vector2 {
    const length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
    if (length === 0) return { x: 0, y: 0 };
    return { x: vector.x / length, y: vector.y / length };
}

/**
 * Calculate dot product of two vectors
 */
export function dotProduct(a: Vector2, b: Vector2): number {
    return a.x * b.x + a.y * b.y;
}

/**
 * Create a new Rectangle
 */
export function createRectangle(x: number = 0, y: number = 0, width: number = 0, height: number = 0): Rectangle {
    return { x, y, width, height };
}

/**
 * Check if a point is inside a rectangle
 */
export function pointInRectangle(point: Vector2, rect: Rectangle): boolean {
    return point.x >= rect.x &&
        point.x <= rect.x + rect.width &&
        point.y >= rect.y &&
        point.y <= rect.y + rect.height;
}

/**
 * Get the center point of a rectangle
 */
export function rectangleCenter(rect: Rectangle): Vector2 {
    return {
        x: rect.x + rect.width / 2,
        y: rect.y + rect.height / 2,
    };
}

/**
 * Check if two rectangles intersect
 */
export function rectanglesIntersect(a: Rectangle, b: Rectangle): boolean {
    return !(a.x + a.width <= b.x ||
        b.x + b.width <= a.x ||
        a.y + a.height <= b.y ||
        b.y + b.height <= a.y);
}

/**
 * Clamp a value between min and max
 */
export function clamp(value: number, min: number, max: number): number {
    return Math.min(Math.max(value, min), max);
}

/**
 * Linear interpolation between two values
 */
export function lerp(a: number, b: number, t: number): number {
    return a + (b - a) * t;
}

/**
 * Convert degrees to radians
 */
export function degreesToRadians(degrees: number): number {
    return degrees * (Math.PI / 180);
}

/**
 * Convert radians to degrees
 */
export function radiansToDegrees(radians: number): number {
    return radians * (180 / Math.PI);
}
</file>

<file path="src/util/levels.ts">
/**
 * Level Progression System
 *
 * Adapted from Banana Music Game's level specs
 * Defines preset layouts with increasing difficulty
 */

export interface LevelSpec {
    /** Number of brick rows */
    readonly rows: number;
    /** Number of brick columns */
    readonly cols: number;
    /** Function to calculate HP per row (optional, defaults to 1) */
    readonly hpPerRow?: (row: number) => number;
    /** Starting Y position for brick field */
    readonly startY?: number;
    /** Gap between bricks */
    readonly gap?: number;
    /** Power-up spawn chance multiplier (1.0 = normal) */
    readonly powerUpChanceMultiplier?: number;
}

export interface LevelLayout {
    /** Brick positions and properties */
    readonly bricks: readonly BrickSpec[];
    /** Total breakable bricks count */
    readonly breakableCount: number;
    /** Level specification used */
    readonly spec: LevelSpec;
}

export interface BrickSpec {
    /** Grid row index */
    readonly row: number;
    /** Grid column index */
    readonly col: number;
    /** World X position */
    readonly x: number;
    /** World Y position */
    readonly y: number;
    /** Hit points (how many hits to break) */
    readonly hp: number;
}

/** Default level presets with progressive difficulty */
const LEVEL_PRESETS: readonly LevelSpec[] = [
    // Level 1: Simple 3x6 grid, all 1 HP
    {
        rows: 3,
        cols: 6,
        hpPerRow: () => 1,
        startY: 100,
        gap: 20,
    },
    // Level 2: 4x6 grid, bottom 2 rows have 2 HP
    {
        rows: 4,
        cols: 6,
        hpPerRow: (row) => (row >= 2 ? 2 : 1),
        startY: 100,
        gap: 20,
    },
    // Level 3: 5x7 grid, HP increases with row
    {
        rows: 5,
        cols: 7,
        hpPerRow: (row) => 1 + Math.floor(row / 2),
        startY: 80,
        gap: 18,
        powerUpChanceMultiplier: 1.2,
    },
    // Level 4: 6x8 grid, more variety
    {
        rows: 6,
        cols: 8,
        hpPerRow: (row) => 1 + Math.floor(row / 2),
        startY: 80,
        gap: 16,
        powerUpChanceMultiplier: 1.3,
    },
    // Level 5: Dense 7x9 grid
    {
        rows: 7,
        cols: 9,
        hpPerRow: (row) => Math.max(1, Math.floor(row / 1.5)),
        startY: 60,
        gap: 14,
        powerUpChanceMultiplier: 1.5,
    },
];

/**
 * Get level spec for given index (wraps around after running out of presets)
 *
 * @param levelIndex - Zero-based level index
 * @returns Level specification
 */
export function getLevelSpec(levelIndex: number): LevelSpec {
    const index = Math.max(0, levelIndex);
    return LEVEL_PRESETS[index % LEVEL_PRESETS.length];
}

/**
 * Generate brick layout from level spec
 *
 * @param spec - Level specification
 * @param brickWidth - Width of each brick (default: 100)
 * @param brickHeight - Height of each brick (default: 40)
 * @param fieldWidth - Width of play field (default: 1280)
 * @returns Generated level layout
 */
export function generateLevelLayout(
    spec: LevelSpec,
    brickWidth: number = 100,
    brickHeight: number = 40,
    fieldWidth: number = 1280,
): LevelLayout {
    const gap = spec.gap ?? 20;
    const startY = spec.startY ?? 100;

    // Calculate centering offset
    const totalWidth = spec.cols * brickWidth + (spec.cols - 1) * gap;
    const startX = (fieldWidth - totalWidth) / 2 + brickWidth / 2;

    const bricks: BrickSpec[] = [];

    for (let row = 0; row < spec.rows; row++) {
        const hp = spec.hpPerRow ? spec.hpPerRow(row) : 1;

        for (let col = 0; col < spec.cols; col++) {
            const x = startX + col * (brickWidth + gap);
            const y = startY + row * (brickHeight + gap);

            bricks.push({
                row,
                col,
                x,
                y,
                hp,
            });
        }
    }

    return {
        bricks,
        breakableCount: bricks.length,
        spec,
    };
}

/**
 * Get total number of preset levels
 *
 * @returns Number of preset levels
 */
export function getPresetLevelCount(): number {
    return LEVEL_PRESETS.length;
}

/**
 * Check if level index is beyond presets (will loop)
 *
 * @param levelIndex - Zero-based level index
 * @returns True if beyond original presets
 */
export function isLoopedLevel(levelIndex: number): boolean {
    return levelIndex >= LEVEL_PRESETS.length;
}

/**
 * Calculate difficulty multiplier for level
 * Increases for looped levels to maintain challenge
 *
 * @param levelIndex - Zero-based level index
 * @returns Difficulty multiplier (1.0 = normal)
 */
export function getLevelDifficultyMultiplier(levelIndex: number): number {
    const loopCount = Math.floor(levelIndex / LEVEL_PRESETS.length);
    return 1.0 + loopCount * 0.2; // +20% difficulty per loop
}

/**
 * Get debug info for level
 *
 * @param levelIndex - Zero-based level index
 * @returns Level debug information
 */
export function getLevelDebugInfo(levelIndex: number): {
    levelIndex: number;
    presetIndex: number;
    isLooped: boolean;
    loopCount: number;
    difficultyMultiplier: number;
    spec: LevelSpec;
} {
    const presetIndex = levelIndex % LEVEL_PRESETS.length;
    const loopCount = Math.floor(levelIndex / LEVEL_PRESETS.length);

    return {
        levelIndex,
        presetIndex,
        isLooped: isLoopedLevel(levelIndex),
        loopCount,
        difficultyMultiplier: getLevelDifficultyMultiplier(levelIndex),
        spec: getLevelSpec(levelIndex),
    };
}
</file>

<file path="src/util/paddle-reflection.ts">
/**
 * Paddle Reflection Utilities
 *
 * Adapted from Cloud Popper's paddle reflection system
 * Provides tactical depth by varying bounce angle based on paddle hit location
 */

import { Vector, Body } from 'matter-js';
import type { Vector as Vec } from 'matter-js';

export interface PaddleReflectionConfig {
    /** Width of the paddle for hit offset calculation */
    readonly paddleWidth: number;
    /** Minimum ball speed to maintain (prevents stalling) */
    readonly minSpeed: number;
    /** Maximum angle in radians (default ~75 degrees) */
    readonly maxAngle?: number;
}

const DEFAULT_MAX_ANGLE = Math.PI * 0.42; // ~75 degrees
const EPSILON = 1e-6;

/**
 * Calculate and apply reflection velocity when ball hits paddle
 * Center hits = straight bounces, edge hits = sharper angles
 *
 * @param ball - Ball physics body
 * @param paddle - Paddle physics body
 * @param config - Reflection configuration
 */
export function reflectOffPaddle(ball: Body, paddle: Body, config: PaddleReflectionConfig): void {
    // Calculate hit offset from paddle center (-1 = left edge, +1 = right edge)
    const hitOffset = (ball.position.x - paddle.position.x) / (config.paddleWidth * 0.5);
    const clamped = Math.max(-1, Math.min(1, hitOffset));

    // Convert offset to angle (center = 0°, edges = ±maxAngle)
    const maxAngle = config.maxAngle ?? DEFAULT_MAX_ANGLE;
    const angle = clamped * maxAngle;

    // Calculate current speed (or use minimum)
    const currentSpeed = Vector.magnitude(ball.velocity);
    const speed = Math.max(currentSpeed, config.minSpeed);

    // Create new velocity vector with calculated angle
    // Positive y goes down, so we want negative y for upward bounce
    const newVelocity: Vec = {
        x: Math.sin(angle) * speed,
        y: -Math.abs(Math.cos(angle)) * speed, // Always upward
    };

    Body.setVelocity(ball, newVelocity);
}

/**
 * Calculate reflection data without applying it (for debugging/preview)
 *
 * @param ballX - Ball x position
 * @param paddleX - Paddle x position
 * @param config - Reflection configuration
 * @returns Reflection angle and impact offset
 */
export function calculateReflectionData(
    ballX: number,
    paddleX: number,
    config: PaddleReflectionConfig,
): { angle: number; impactOffset: number } {
    const hitOffset = (ballX - paddleX) / (config.paddleWidth * 0.5);
    const clamped = Math.max(-1, Math.min(1, hitOffset));
    const maxAngle = config.maxAngle ?? DEFAULT_MAX_ANGLE;
    const angle = clamped * maxAngle;

    return {
        angle,
        impactOffset: clamped,
    };
}

/**
 * Get the normalized hit position on paddle (0 = center, ±1 = edges)
 *
 * @param ballX - Ball x position
 * @param paddleX - Paddle x position
 * @param paddleWidth - Paddle width
 * @returns Normalized offset (-1 to +1)
 */
export function getHitOffset(ballX: number, paddleX: number, paddleWidth: number): number {
    const offset = (ballX - paddleX) / (paddleWidth * 0.5);
    return Math.max(-1, Math.min(1, offset));
}
</file>

<file path="src/util/power-ups.ts">
/**
 * Power-Up System
 *
 * Adapted from Banana Music Game's power-up mechanics
 * Spawns temporary power-ups on brick breaks with visual and gameplay effects
 */

export type PowerUpType = 'paddle-width' | 'ball-speed' | 'multi-ball' | 'sticky-paddle';

export interface PowerUpEffect {
    /** Type of power-up */
    readonly type: PowerUpType;
    /** Duration in seconds */
    readonly duration: number;
    /** Remaining time (updated each frame) */
    remainingTime: number;
    /** Start timestamp */
    readonly startTime: number;
}

export interface PowerUpConfig {
    /** Probability of spawning power-up on brick break (0-1) */
    readonly spawnChance?: number;
    /** Default duration for power-ups in seconds */
    readonly defaultDuration?: number;
    /** Paddle width multiplier for paddle-width power-up */
    readonly paddleWidthMultiplier?: number;
    /** Ball speed multiplier for ball-speed power-up */
    readonly ballSpeedMultiplier?: number;
}

const DEFAULT_SPAWN_CHANCE = 0.25; // 25% chance
const DEFAULT_DURATION = 2.5; // seconds
const DEFAULT_PADDLE_WIDTH_MULTIPLIER = 1.5;
const DEFAULT_BALL_SPEED_MULTIPLIER = 1.3;

/**
 * Determine if power-up should spawn
 *
 * @param config - Power-up configuration
 * @returns True if power-up should spawn
 */
export function shouldSpawnPowerUp(config: PowerUpConfig = {}): boolean {
    const chance = config.spawnChance ?? DEFAULT_SPAWN_CHANCE;
    return Math.random() < chance;
}

/**
 * Select random power-up type
 *
 * @returns Random power-up type
 */
export function selectRandomPowerUpType(): PowerUpType {
    const types: PowerUpType[] = ['paddle-width', 'ball-speed', 'multi-ball', 'sticky-paddle'];
    return types[Math.floor(Math.random() * types.length)];
}

/**
 * Create a new power-up effect
 *
 * @param type - Type of power-up
 * @param config - Power-up configuration
 * @param now - Current timestamp (defaults to Date.now)
 * @returns New power-up effect
 */
export function createPowerUpEffect(
    type: PowerUpType,
    config: PowerUpConfig = {},
    now: () => number = Date.now,
): PowerUpEffect {
    const duration = config.defaultDuration ?? DEFAULT_DURATION;
    const startTime = now();

    return {
        type,
        duration,
        remainingTime: duration,
        startTime,
    };
}

/**
 * Update power-up effect timer
 *
 * @param effect - Power-up effect to update (mutates in place)
 * @param deltaSeconds - Time elapsed since last update
 * @returns True if effect is still active, false if expired
 */
export function updatePowerUpEffect(effect: PowerUpEffect, deltaSeconds: number): boolean {
    effect.remainingTime = Math.max(0, effect.remainingTime - deltaSeconds);
    return effect.remainingTime > 0;
}

/**
 * Check if power-up is in fade-out period (last 25% of duration)
 *
 * @param effect - Power-up effect
 * @returns True if in fade-out period
 */
export function isPowerUpFadingOut(effect: PowerUpEffect): boolean {
    const fadeThreshold = effect.duration * 0.25;
    return effect.remainingTime > 0 && effect.remainingTime <= fadeThreshold;
}

/**
 * Get power-up intensity factor (1.0 at start, fades to 0 during fade-out)
 *
 * @param effect - Power-up effect
 * @returns Intensity factor (0-1)
 */
export function getPowerUpIntensity(effect: PowerUpEffect): number {
    if (effect.remainingTime <= 0) {
        return 0;
    }

    const fadeThreshold = effect.duration * 0.25;
    if (effect.remainingTime <= fadeThreshold) {
        // Fade from 1 to 0 during last 25%
        return effect.remainingTime / fadeThreshold;
    }

    return 1;
}

/**
 * Calculate paddle width scale based on active power-up
 *
 * @param effect - Power-up effect (or null if none active)
 * @param config - Power-up configuration
 * @returns Scale multiplier (1.0 = normal, >1.0 = wider)
 */
export function calculatePaddleWidthScale(effect: PowerUpEffect | null, config: PowerUpConfig = {}): number {
    if (!effect || effect.type !== 'paddle-width' || effect.remainingTime <= 0) {
        return 1.0;
    }

    const maxMultiplier = config.paddleWidthMultiplier ?? DEFAULT_PADDLE_WIDTH_MULTIPLIER;
    const intensity = getPowerUpIntensity(effect);

    // Lerp from 1.0 to maxMultiplier based on intensity
    return 1.0 + (maxMultiplier - 1.0) * intensity;
}

/**
 * Calculate ball speed scale based on active power-up
 *
 * @param effect - Power-up effect (or null if none active)
 * @param config - Power-up configuration
 * @returns Scale multiplier (1.0 = normal, >1.0 = faster)
 */
export function calculateBallSpeedScale(effect: PowerUpEffect | null, config: PowerUpConfig = {}): number {
    if (!effect || effect.type !== 'ball-speed' || effect.remainingTime <= 0) {
        return 1.0;
    }

    const maxMultiplier = config.ballSpeedMultiplier ?? DEFAULT_BALL_SPEED_MULTIPLIER;
    const intensity = getPowerUpIntensity(effect);

    return 1.0 + (maxMultiplier - 1.0) * intensity;
}

/**
 * Power-up manager to track multiple active effects
 */
export class PowerUpManager {
    private effects: Map<PowerUpType, PowerUpEffect> = new Map();

    /**
     * Activate a power-up (replaces existing effect of same type)
     *
     * @param type - Power-up type
     * @param config - Power-up configuration
     * @param now - Current timestamp function
     */
    activate(type: PowerUpType, config: PowerUpConfig = {}, now: () => number = Date.now): void {
        const effect = createPowerUpEffect(type, config, now);
        this.effects.set(type, effect);
    }

    /**
     * Update all active power-ups
     *
     * @param deltaSeconds - Time elapsed since last update
     */
    update(deltaSeconds: number): void {
        for (const [type, effect] of this.effects) {
            if (!updatePowerUpEffect(effect, deltaSeconds)) {
                this.effects.delete(type);
            }
        }
    }

    /**
     * Get active effect of specific type
     *
     * @param type - Power-up type
     * @returns Active effect or null
     */
    getEffect(type: PowerUpType): PowerUpEffect | null {
        return this.effects.get(type) ?? null;
    }

    /**
     * Check if power-up is active
     *
     * @param type - Power-up type
     * @returns True if active
     */
    isActive(type: PowerUpType): boolean {
        const effect = this.effects.get(type);
        return effect !== undefined && effect.remainingTime > 0;
    }

    /**
     * Clear all active power-ups
     */
    clearAll(): void {
        this.effects.clear();
    }

    /**
     * Get all active effects
     */
    getActiveEffects(): PowerUpEffect[] {
        return Array.from(this.effects.values());
    }
}
</file>

<file path="src/util/scoring.ts">
/**
 * Combo-Based Scoring System
 *
 * Adapted from Banana Music Game's scoring mechanics
 * Rewards chains with multipliers and decays over time
 */

export interface ScoreState {
    /** Current total score */
    score: number;
    /** Current combo count */
    combo: number;
    /** Time remaining before combo resets (in seconds) */
    comboTimer: number;
    /** Callback to update HUD/UI */
    updateHUD?: () => void;
}

export interface ScoringConfig {
    /** Base points per brick break */
    readonly basePoints?: number;
    /** Combo threshold for multiplier increase (default: 8) */
    readonly multiplierThreshold?: number;
    /** Multiplier increase per threshold (default: 0.25 = +25%) */
    readonly multiplierPerThreshold?: number;
    /** Combo decay timer duration in seconds (default: 1.6) */
    readonly comboDecayTime?: number;
}

const DEFAULT_BASE_POINTS = 10;
const DEFAULT_MULTIPLIER_THRESHOLD = 8;
const DEFAULT_MULTIPLIER_PER_THRESHOLD = 0.25;
const DEFAULT_COMBO_DECAY_TIME = 1.6;

/**
 * Create a new scoring state
 *
 * @param updateHUD - Optional callback to trigger HUD updates
 * @returns Initial score state
 */
export function createScoring(updateHUD?: () => void): ScoreState {
    return {
        score: 0,
        combo: 0,
        comboTimer: 0,
        updateHUD,
    };
}

/**
 * Award points for brick break with combo multiplier
 *
 * @param state - Score state to update (mutates in place)
 * @param config - Scoring configuration
 * @returns Points awarded
 */
export function awardBrickPoints(state: ScoreState, config: ScoringConfig = {}): number {
    const basePoints = config.basePoints ?? DEFAULT_BASE_POINTS;
    const threshold = config.multiplierThreshold ?? DEFAULT_MULTIPLIER_THRESHOLD;
    const multiplierPer = config.multiplierPerThreshold ?? DEFAULT_MULTIPLIER_PER_THRESHOLD;
    const decayTime = config.comboDecayTime ?? DEFAULT_COMBO_DECAY_TIME;

    // Calculate multiplier based on combo threshold
    const multiplier = 1 + Math.floor(state.combo / threshold) * multiplierPer;
    const points = Math.round(basePoints * multiplier);

    // Update state
    state.score += points;
    state.combo += 1;
    state.comboTimer = decayTime; // Reset decay timer

    // Trigger HUD update if callback provided
    state.updateHUD?.();

    return points;
}

/**
 * Decay combo over time, resetting when timer reaches zero
 *
 * @param state - Score state to update (mutates in place)
 * @param deltaSeconds - Time elapsed since last update (in seconds)
 */
export function decayCombo(state: ScoreState, deltaSeconds: number): void {
    if (state.comboTimer > 0) {
        state.comboTimer -= deltaSeconds;
        if (state.comboTimer <= 0) {
            state.combo = 0;
            state.comboTimer = 0;
            state.updateHUD?.();
        }
    }
}

/**
 * Reset combo immediately (e.g., on life lost)
 *
 * @param state - Score state to update (mutates in place)
 */
export function resetCombo(state: ScoreState): void {
    state.combo = 0;
    state.comboTimer = 0;
    state.updateHUD?.();
}

/**
 * Get current combo multiplier
 *
 * @param combo - Current combo count
 * @param config - Scoring configuration
 * @returns Current multiplier (1.0 = no bonus)
 */
export function getComboMultiplier(combo: number, config: ScoringConfig = {}): number {
    const threshold = config.multiplierThreshold ?? DEFAULT_MULTIPLIER_THRESHOLD;
    const multiplierPer = config.multiplierPerThreshold ?? DEFAULT_MULTIPLIER_PER_THRESHOLD;
    return 1 + Math.floor(combo / threshold) * multiplierPer;
}

/**
 * Check if combo reached a milestone threshold
 *
 * @param combo - Current combo count
 * @param threshold - Milestone threshold
 * @returns True if combo is exactly at a multiple of threshold
 */
export function isComboMilestone(combo: number, threshold: number = DEFAULT_MULTIPLIER_THRESHOLD): boolean {
    return combo > 0 && combo % threshold === 0;
}

/**
 * Get scoring debug info
 *
 * @param state - Score state
 * @param config - Scoring configuration
 * @returns Debug information about scoring state
 */
export function getScoringDebugInfo(state: ScoreState, config: ScoringConfig = {}): {
    score: number;
    combo: number;
    comboTimer: number;
    multiplier: number;
    nextMilestone: number;
    comboActive: boolean;
} {
    const threshold = config.multiplierThreshold ?? DEFAULT_MULTIPLIER_THRESHOLD;
    const multiplier = getComboMultiplier(state.combo, config);
    const nextMilestone = Math.ceil(state.combo / threshold) * threshold;

    return {
        score: state.score,
        combo: state.combo,
        comboTimer: state.comboTimer,
        multiplier,
        nextMilestone,
        comboActive: state.comboTimer > 0,
    };
}
</file>

<file path="src/util/speed-regulation.ts">
/**
 * Speed Regulation Utilities
 *
 * Adapted from Cloud Popper's speed regulation system
 * Prevents ball from getting too slow (boring) or too fast (unplayable)
 */

import { Vector, Body } from 'matter-js';

export interface SpeedRegulationConfig {
    /** Base speed to maintain (target speed) */
    readonly baseSpeed: number;
    /** Maximum allowed speed (prevents tunneling) */
    readonly maxSpeed: number;
}

const EPSILON = 1e-6;

/**
 * Regulate ball speed to stay within configured bounds
 * Clamps velocity to [baseSpeed, maxSpeed] range
 *
 * @param body - Physics body to regulate
 * @param config - Speed regulation config
 */
export function regulateSpeed(body: Body, config: SpeedRegulationConfig): void {
    const velocity = body.velocity;
    const speed = Vector.magnitude(velocity);

    // Handle near-zero velocity (avoid division by zero)
    if (speed < EPSILON) {
        const newVelocity = Vector.mult(velocity, config.baseSpeed / EPSILON);
        Body.setVelocity(body, newVelocity);
        return;
    }

    // Speed too slow - boost to base speed
    if (speed < config.baseSpeed) {
        const scaledVelocity = Vector.mult(velocity, config.baseSpeed / speed);
        Body.setVelocity(body, scaledVelocity);
        return;
    }

    // Speed too fast - clamp to max speed
    if (speed > config.maxSpeed) {
        const scaledVelocity = Vector.mult(velocity, config.maxSpeed / speed);
        Body.setVelocity(body, scaledVelocity);
    }
}

/**
 * Check if ball speed is within acceptable range
 *
 * @param body - Physics body to check
 * @param config - Speed regulation config
 * @returns True if speed is within [baseSpeed, maxSpeed]
 */
export function isSpeedWithinRange(body: Body, config: SpeedRegulationConfig): boolean {
    const speed = Vector.magnitude(body.velocity);
    return speed >= config.baseSpeed && speed <= config.maxSpeed;
}

/**
 * Get speed regulation debug info
 *
 * @param body - Physics body to inspect
 * @param config - Speed regulation config
 * @returns Debug information about current speed state
 */
export function getSpeedDebugInfo(
    body: Body,
    config: SpeedRegulationConfig,
): {
    currentSpeed: number;
    baseSpeed: number;
    maxSpeed: number;
    isTooSlow: boolean;
    isTooFast: boolean;
    isWithinRange: boolean;
} {
    const speed = Vector.magnitude(body.velocity);

    return {
        currentSpeed: speed,
        baseSpeed: config.baseSpeed,
        maxSpeed: config.maxSpeed,
        isTooSlow: speed < config.baseSpeed,
        isTooFast: speed > config.maxSpeed,
        isWithinRange: speed >= config.baseSpeed && speed <= config.maxSpeed,
    };
}
</file>

<file path="tests/unit/app/loop.spec.ts">
import { beforeEach, describe, expect, it, vi } from 'vitest';
import type { Application } from 'pixi.js';
import { createGameLoop, DEFAULT_STEP_MS } from '@app/loop';

type RafHandle = number;

type FrameCallback = (timestamp: number) => void;

interface FakeRaf {
    readonly request: (callback: FrameCallback) => RafHandle;
    readonly cancel: (handle: RafHandle) => void;
    readonly flush: (deltaMs: number) => void;
    readonly size: () => number;
}

const createFakeRaf = (getTime: () => number, setTime: (next: number) => void): FakeRaf => {
    let nextId = 1;
    const callbacks = new Map<RafHandle, FrameCallback>();

    return {
        request: (callback) => {
            const handle = nextId++;
            callbacks.set(handle, callback);
            return handle;
        },
        cancel: (handle) => {
            callbacks.delete(handle);
        },
        flush: (deltaMs) => {
            const previous = [...callbacks.values()];
            callbacks.clear();
            setTime(getTime() + deltaMs);
            previous.forEach((callback) => callback(getTime()));
        },
        size: () => callbacks.size,
    };
};

const createStageStub = (renderSpy = vi.fn()): { renderSpy: ReturnType<typeof vi.fn>; stage: { app: Application } } => {
    const app = { render: renderSpy } as unknown as Application;
    return { renderSpy, stage: { app } };
};

describe('createGameLoop', () => {
    const stepMs = 10;

    let currentTime: number;
    let setTime: (next: number) => void;
    let fakeRaf: FakeRaf;

    beforeEach(() => {
        currentTime = 0;
        setTime = (next) => {
            currentTime = next;
        };
        fakeRaf = createFakeRaf(
            () => currentTime,
            setTime,
        );
    });

    it('steps the physics world on a fixed timestep and renders each frame', () => {
        const worldStep = vi.fn();
        const beforeStep = vi.fn();
        const afterStep = vi.fn();
        const beforeRender = vi.fn();
        const afterRender = vi.fn();
        const { renderSpy, stage } = createStageStub();

        const loop = createGameLoop({
            world: { step: worldStep },
            stage,
            stepMs,
            hooks: {
                beforeStep,
                afterStep,
                beforeRender,
                afterRender,
            },
            now: () => currentTime,
            requestFrame: fakeRaf.request,
            cancelFrame: fakeRaf.cancel,
        });

        loop.start();
        expect(fakeRaf.size()).toBe(1);

        fakeRaf.flush(stepMs / 2);
        expect(worldStep).not.toHaveBeenCalled();
        expect(renderSpy).toHaveBeenCalledTimes(1);
        expect(beforeRender).toHaveBeenCalledWith(0.5);

        fakeRaf.flush(stepMs / 2);
        expect(worldStep).toHaveBeenCalledTimes(1);
        expect(worldStep).toHaveBeenCalledWith(stepMs);
        expect(beforeStep).toHaveBeenCalledWith(stepMs);
        expect(afterStep).toHaveBeenCalledWith(stepMs);
        expect(renderSpy).toHaveBeenCalledTimes(2);
        expect(afterRender).toHaveBeenCalledTimes(2);
    });

    it('stops scheduling frames when stopped', () => {
        const worldStep = vi.fn();
        const { stage } = createStageStub();

        const loop = createGameLoop({
            world: { step: worldStep },
            stage,
            stepMs,
            now: () => currentTime,
            requestFrame: fakeRaf.request,
            cancelFrame: fakeRaf.cancel,
        });

        loop.start();
        expect(fakeRaf.size()).toBe(1);

        loop.stop();
        expect(fakeRaf.size()).toBe(0);

        fakeRaf.flush(stepMs);
        expect(worldStep).not.toHaveBeenCalled();
    });

    it('limits the number of physics sub-steps per frame', () => {
        const worldStep = vi.fn();
        const { stage } = createStageStub();

        const loop = createGameLoop({
            world: { step: worldStep },
            stage,
            stepMs,
            maxStepsPerFrame: 3,
            now: () => currentTime,
            requestFrame: fakeRaf.request,
            cancelFrame: fakeRaf.cancel,
        });

        loop.start();
        fakeRaf.flush(stepMs * 10);

        expect(worldStep).toHaveBeenCalledTimes(3);
        worldStep.mockClear();

        fakeRaf.flush(stepMs);
        expect(worldStep).toHaveBeenCalledTimes(1);
    });

    it('ignores subsequent start calls while already running', () => {
        const worldStep = vi.fn();
        const { stage } = createStageStub();

        const loop = createGameLoop({
            world: { step: worldStep },
            stage,
            now: () => currentTime,
            requestFrame: fakeRaf.request,
            cancelFrame: fakeRaf.cancel,
        });

        loop.start();
        loop.start();

        expect(fakeRaf.size()).toBe(1);
    });

    it('exposes the default step interval constant', () => {
        expect(DEFAULT_STEP_MS).toBeCloseTo(1000 / 120, 5);
    });
});
</file>

<file path="tests/unit/app/preloader.spec.ts">
import { describe, expect, it, vi } from 'vitest';
import { createPreloader, type ProgressReporter } from '@app/preloader';

describe('createPreloader', () => {
    const createContainer = () => {
        const container = document.createElement('div');
        document.body.appendChild(container);
        return container;
    };

    it('loads assets and presents the start prompt', async () => {
        const container = createContainer();
        const loadAssets = vi.fn(async (report: ProgressReporter) => {
            report({ loaded: 2, total: 4 });
            report({ loaded: 4, total: 4 });
        });

        const preloader = createPreloader({
            container,
            promptText: 'Tap to start',
            loadAssets,
        });

        await preloader.prepare();

        expect(preloader.status()).toBe('awaiting-interaction');
        expect(preloader.progress()).toEqual({ loaded: 4, total: 4 });
        expect(loadAssets).toHaveBeenCalledTimes(1);

        const prompt = container.querySelector('button[data-role="start-prompt"]');
        expect(prompt).not.toBeNull();
        expect(prompt?.textContent).toContain('Tap to start');
        preloader.destroy();
        container.remove();
    });

    it('invokes the start callback and completes once the user interacts', async () => {
        const container = createContainer();
        const onStart = vi.fn();

        const preloader = createPreloader({
            container,
            loadAssets: async (report: ProgressReporter) => {
                report({ loaded: 1, total: 1 });
            },
            onStart,
        });

        await preloader.prepare();

        const prompt = container.querySelector('button[data-role="start-prompt"]') as HTMLButtonElement;
        prompt.click();
        await Promise.resolve();

        expect(onStart).toHaveBeenCalledTimes(1);
        expect(preloader.status()).toBe('completed');
        expect(container.querySelector('button[data-role="start-prompt"]')).toBeNull();

        preloader.destroy();
        container.remove();
    });

    it('marks the preloader as failed when asset loading throws', async () => {
        const container = createContainer();
        const error = new Error('load failed');

        const preloader = createPreloader({
            container,
            loadAssets: async () => {
                throw error;
            },
        });

        await expect(preloader.prepare()).rejects.toThrow(error);
        expect(preloader.status()).toBe('failed');
        expect(container.querySelector('button[data-role="start-prompt"]')).toBeNull();

        preloader.destroy();
        container.remove();
    });
});
</file>

<file path="tests/unit/cli/simulate.spec.ts">
import { describe, expect, it } from 'vitest';
import { createSimulateCommand, runHeadlessSimulation } from '@cli/simulate';

describe('simulate CLI command', () => {
    it('produces deterministic results for the same seed', async () => {
        const input = {
            mode: 'simulate' as const,
            seed: 21,
            round: 2,
            durationSec: 90,
            options: {
                audio: false,
                visual: false,
                telemetry: true,
            },
        };

        const first = await runHeadlessSimulation(input);
        const second = await runHeadlessSimulation(input);

        expect(second).toEqual(first);
    });

    it('writes simulation summary to stdout and returns zero exit code', async () => {
        const writes: string[] = [];
        const errors: string[] = [];
        const input = {
            mode: 'simulate' as const,
            seed: 7,
            round: 1,
            durationSec: 120,
            options: {
                audio: false,
                visual: false,
                telemetry: true,
            },
        };

        const command = createSimulateCommand({
            readStdin: async () => JSON.stringify(input),
            writeStdout: async (value: string) => {
                writes.push(value);
            },
            writeStderr: async (value: string) => {
                errors.push(value);
            },
        });

        const exitCode = await command.execute();

        expect(exitCode).toBe(0);
        expect(errors[0]).toContain('simulate');
        expect(writes).toHaveLength(1);
        const output = JSON.parse(writes[0]);
        const baseline = await runHeadlessSimulation(input);

        expect(output).toMatchObject({
            ok: true,
            sessionId: 'sim-7-r1',
            events: expect.any(Number),
            score: expect.any(Number),
            volleyStats: {
                longestVolley: expect.any(Number),
                averageSpeed: expect.any(Number),
            },
        });
        expect(output).toEqual(baseline);
    });

    it('returns non-zero exit code and logs an error for invalid input', async () => {
        const writes: string[] = [];
        const errors: string[] = [];

        const command = createSimulateCommand({
            readStdin: async () => 'not-json',
            writeStdout: async (value: string) => {
                writes.push(value);
            },
            writeStderr: async (value: string) => {
                errors.push(value);
            },
        });

        const exitCode = await command.execute();

        expect(exitCode).toBe(1);
        expect(writes).toHaveLength(0);
        expect(errors[0]).toContain('Failed to read simulation input');
    });
});
</file>

<file path="tests/unit/physics/world.spec.ts">
import { describe, expect, it } from 'vitest';
import type { Body } from 'matter-js';
import { createPhysicsWorld } from '@physics/world';

describe('createPhysicsWorld', () => {
    it('applies gravity and steps bodies forward', () => {
        const handle = createPhysicsWorld({ gravity: 1.2 });
        const ball = handle.factory.ball({ radius: 20, position: { x: 150, y: 0 } });

        handle.add(ball);

        const startY = ball.position.y;
        handle.step();

        expect(ball.position.y).toBeGreaterThan(startY);
        expect(handle.engine.world.gravity.y).toBeCloseTo(1.2, 5);

        handle.dispose();
    });

    it('creates static boundary walls sized to the playfield', () => {
        const handle = createPhysicsWorld({
            gravity: 0,
            dimensions: { width: 800, height: 600, wallThickness: 16 },
        });

        const walls = handle.factory.bounds();

        const getLabel = (body: Body): string => body.label;

        expect(walls).toHaveLength(4);
        expect(walls.map(getLabel)).toEqual(['wall-top', 'wall-right', 'wall-bottom', 'wall-left']);
        walls.forEach((wall: Body) => {
            expect(wall.isStatic).toBe(true);
        });

        handle.add(walls);
        expect(handle.world.bodies).toContain(walls[0]);

        handle.dispose();
    });

    it('creates paddle and brick bodies with sensible defaults', () => {
        const handle = createPhysicsWorld();

        const paddle = handle.factory.paddle({
            size: { width: 150, height: 18 },
            position: { x: 200, y: 540 },
        });
        const brick = handle.factory.brick({
            size: { width: 48, height: 20 },
            position: { x: 100, y: 120 },
        });

        expect(paddle.label).toBe('paddle');
        expect(paddle.isStatic).toBe(true);
        expect(brick.label).toBe('brick');
        expect(brick.isStatic).toBe(true);

        handle.dispose();
    });
});
</file>

<file path="tests/unit/render/hud.spec.ts">
import { describe, expect, it } from 'vitest';
import { buildHudScoreboard } from '@render/hud';
import type { GameSessionSnapshot } from '@app/state';

const createSnapshot = (overrides: Partial<GameSessionSnapshot> = {}): GameSessionSnapshot => {
    const base: GameSessionSnapshot = {
        sessionId: 'session-001',
        status: 'active',
        score: 4250,
        livesRemaining: 2,
        round: 3,
        elapsedTimeMs: 120_000,
        brickTotal: 96,
        brickRemaining: 32,
        lastOutcome: undefined,
        momentum: {
            volleyLength: 9,
            speedPressure: 0.62,
            brickDensity: 32 / 96,
            comboHeat: 7,
            updatedAt: 120_000,
        },
        audio: {
            scene: 'focused',
            nextScene: 'tense',
            barCountdown: 1,
            sends: { reverb: 0.25, delay: 0.18 },
            primaryLayerActive: true,
        },
        preferences: {
            masterVolume: 0.8,
            muted: false,
            reducedMotion: false,
            controlScheme: 'keyboard',
            controlSensitivity: 0.5,
        },
        hud: {
            score: 4250,
            lives: 2,
            round: 3,
            brickRemaining: 32,
            brickTotal: 96,
            momentum: {
                volleyLength: 9,
                speedPressure: 0.62,
                brickDensity: 32 / 96,
                comboHeat: 7,
            },
            audio: {
                scene: 'focused',
                nextScene: 'tense',
                barCountdown: 1,
            },
            prompts: [
                {
                    id: 'momentum-warning',
                    severity: 'warning',
                    message: 'Momentum dropping — keep rally alive!',
                },
            ],
            settings: {
                muted: false,
                masterVolume: 0.8,
                reducedMotion: false,
            },
        },
        updatedAt: 120_000,
    };

    return { ...base, ...overrides };
};

describe('buildHudScoreboard', () => {
    it('formats score, lives, and brick progress for display', () => {
        const snapshot = createSnapshot();

        const view = buildHudScoreboard(snapshot);

        expect(view.statusText).toBe('Round 3 — Active');
        expect(view.entries).toContainEqual({ id: 'score', label: 'Score', value: '4,250' });
        expect(view.entries).toContainEqual({ id: 'lives', label: 'Lives', value: '❤❤' });
        expect(view.entries).toContainEqual({ id: 'bricks', label: 'Bricks', value: '32 / 96 (67%)' });
        expect(view.entries).toContainEqual({ id: 'momentum', label: 'Momentum', value: 'Heat 7 · Volley 9' });
    });

    it('surfaces completed status and prompts when the round ends', () => {
        const snapshot = createSnapshot({
            status: 'completed',
            lastOutcome: {
                result: 'win',
                round: 3,
                scoreAwarded: 6800,
                durationMs: 95_000,
                timestamp: 215_000,
            },
            hud: {
                score: 6800,
                lives: 2,
                round: 3,
                brickRemaining: 0,
                brickTotal: 96,
                momentum: {
                    volleyLength: 12,
                    speedPressure: 0.85,
                    brickDensity: 0,
                    comboHeat: 12,
                },
                audio: {
                    scene: 'climax',
                    nextScene: null,
                    barCountdown: 0,
                },
                prompts: [
                    {
                        id: 'round-complete',
                        severity: 'info',
                        message: 'Round complete — tap to continue',
                    },
                ],
                settings: {
                    muted: false,
                    masterVolume: 0.8,
                    reducedMotion: false,
                },
            },
        });

        const view = buildHudScoreboard(snapshot);

        expect(view.statusText).toBe('Round 3 — Completed');
        expect(view.prompts).toEqual([
            {
                id: 'round-complete',
                message: 'Round complete — tap to continue',
                severity: 'info',
            },
        ]);
        expect(view.summaryLine).toBe('Win in 95s · Score +6,800');
    });

    it('indicates failure and handles muted preferences', () => {
        const snapshot = createSnapshot({
            status: 'failed',
            livesRemaining: 0,
            preferences: {
                masterVolume: 0,
                muted: true,
                reducedMotion: true,
                controlScheme: 'touch',
                controlSensitivity: 0.75,
            },
            hud: {
                score: 1800,
                lives: 0,
                round: 3,
                brickRemaining: 12,
                brickTotal: 96,
                momentum: {
                    volleyLength: 3,
                    speedPressure: 0.2,
                    brickDensity: 0.125,
                    comboHeat: 1,
                },
                audio: {
                    scene: 'calm',
                    nextScene: 'focused',
                    barCountdown: 2,
                },
                prompts: [
                    {
                        id: 'round-failed',
                        severity: 'error',
                        message: 'All lives lost — press retry',
                    },
                ],
                settings: {
                    muted: true,
                    masterVolume: 0,
                    reducedMotion: true,
                },
            },
            lastOutcome: {
                result: 'loss',
                round: 3,
                scoreAwarded: 0,
                durationMs: 64_000,
                timestamp: 184_000,
            },
        });

        const view = buildHudScoreboard(snapshot);

        expect(view.statusText).toBe('Round 3 — Failed');
        expect(view.summaryLine).toBe('Loss in 64s');
        expect(view.entries).toContainEqual({ id: 'audio', label: 'Audio', value: 'Muted' });
    });
});
</file>

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# Build artifacts
build/

# OS-specific files
.DS_Store
Thumbs.db

# Editor settings
.vscode/
.idea/

# Temporary files
*.tmp
*.swp
</file>

<file path="package.json">
{
  "name": "lucky-break",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "packageManager": "pnpm@8.15.4",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test": "vitest run",
    "test:watch": "vitest",
    "lint": "eslint \"{src,tests}/**/*.ts\" --max-warnings=0 --no-error-on-unmatched-pattern",
    "lint:fix": "eslint \"{src,tests}/**/*.ts\" --max-warnings=0 --fix --no-error-on-unmatched-pattern",
    "format": "prettier --write \"**/*.{ts,tsx,js,json,md,css,html}\"",
    "format:check": "prettier --check \"**/*.{ts,tsx,js,json,md,css,html}\"",
    "cli:simulate": "node ./dist/cli/index.js"
  },
  "dependencies": {
    "matter-js": "^0.20.0",
    "pixi.js": "^8.14.0",
    "tone": "^15.1.22"
  },
  "devDependencies": {
    "@testing-library/dom": "^10.4.1",
    "@testing-library/jest-dom": "^6.9.1",
    "@types/matter-js": "^0.20.2",
    "@types/node": "^24.7.2",
    "@typescript-eslint/eslint-plugin": "^8.46.1",
    "@typescript-eslint/parser": "^8.46.1",
    "@vitest/coverage-v8": "^1.6.0",
    "eslint": "^9.37.0",
    "eslint-config-prettier": "^10.1.8",
    "eslint-plugin-import": "^2.32.0",
    "jsdom": "^27.0.0",
    "prettier": "^3.6.2",
    "typescript": "^5.9.3",
    "typescript-eslint": "^8.46.1",
    "vite": "^7.1.10",
    "vitest": "^1.6.0"
  }
}
</file>

<file path="src/app/preloader.ts">
export type PreloaderStatus = 'idle' | 'loading' | 'awaiting-interaction' | 'completed' | 'failed';

export interface PreloaderProgress {
    readonly loaded: number;
    readonly total: number;
}

export type ProgressReporter = (progress: PreloaderProgress) => void;
export type AssetLoader = (report: ProgressReporter) => Promise<void>;
export type StartCallback = () => void | Promise<void>;
export type ErrorCallback = (error: unknown) => void;

export interface PreloaderOptions {
    readonly container: HTMLElement;
    readonly promptText?: string;
    readonly loadAssets?: AssetLoader;
    readonly onStart?: StartCallback;
    readonly onError?: ErrorCallback;
    readonly document?: Document;
    readonly startEvents?: readonly ('click' | 'keydown' | 'pointerdown')[];
}

export interface PreloaderHandle {
    readonly prepare: () => Promise<void>;
    readonly status: () => PreloaderStatus;
    readonly progress: () => PreloaderProgress;
    readonly destroy: () => void;
}

const DEFAULT_PROMPT_TEXT = 'Tap to start';
const DEFAULT_EVENTS: ReadonlyArray<'click' | 'keydown' | 'pointerdown'> = ['click', 'keydown'];

const clampProgress = (value: number): number => (Number.isFinite(value) && value >= 0 ? value : 0);

const defaultLoader: AssetLoader = async (report) => {
    report({ loaded: 1, total: 1 });
};

export const createPreloader = (options: PreloaderOptions): PreloaderHandle => {
    const container = options.container;
    const documentRef = options.document ?? container.ownerDocument ?? document;
    const loadAssets = options.loadAssets ?? defaultLoader;
    const promptText = options.promptText ?? DEFAULT_PROMPT_TEXT;
    const startEvents = options.startEvents ?? DEFAULT_EVENTS;

    const root = documentRef.createElement('div');
    root.className = 'lb-preloader';
    root.dataset.state = 'idle';

    const progressBar = documentRef.createElement('div');
    progressBar.className = 'lb-preloader__progress';
    progressBar.dataset.role = 'progress';
    progressBar.dataset.progress = '0.00';
    progressBar.textContent = '0%';
    root.appendChild(progressBar);
    container.appendChild(root);

    let status: PreloaderStatus = 'idle';
    let progress: PreloaderProgress = { loaded: 0, total: 0 };
    let promptButton: HTMLButtonElement | null = null;
    const promptListeners: Array<{ type: string; handler: EventListener }> = [];
    let preparePromise: Promise<void> | undefined;
    let disposed = false;
    let starting = false;

    const updateState = (next: PreloaderStatus) => {
        status = next;
        root.dataset.state = next;
    };

    const updateProgress = (next: PreloaderProgress) => {
        const loaded = clampProgress(next.loaded);
        const total = Math.max(clampProgress(next.total), 0);
        progress = { loaded, total };

        const ratio = total > 0 ? Math.max(0, Math.min(1, loaded / total)) : 0;
        progressBar.dataset.progress = ratio.toFixed(2);
        progressBar.style.setProperty('--progress', ratio.toString());
        progressBar.textContent = `${Math.round(ratio * 100)}%`;
    };

    const removePrompt = () => {
        if (!promptButton) {
            return;
        }

        promptListeners.forEach(({ type, handler }) => {
            promptButton?.removeEventListener(type, handler);
        });
        promptListeners.length = 0;
        promptButton.remove();
        promptButton = null;
    };

    const fail = (error: unknown): never => {
        updateState('failed');
        removePrompt();
        options.onError?.(error);
        throw error instanceof Error ? error : new Error(String(error));
    };

    const triggerStart = async (): Promise<void> => {
        if (status !== 'awaiting-interaction' || starting) {
            return;
        }

        starting = true;
        try {
            await options.onStart?.();
            updateState('completed');
            removePrompt();
            if (root.parentElement === container) {
                root.remove();
            }
        } catch (error) {
            fail(error);
        } finally {
            starting = false;
        }
    };

    const handleEvent = (event: Event): void => {
        if (!promptButton) {
            return;
        }

        if (event.type === 'keydown') {
            const key = (event as KeyboardEvent).key;
            if (key !== 'Enter' && key !== ' ') {
                return;
            }
        }

        event.preventDefault();
        void triggerStart().catch(() => {
            /* error already reported via onError */
        });
    };

    const ensurePrompt = () => {
        if (disposed || promptButton) {
            updateState('awaiting-interaction');
            return;
        }

        promptButton = documentRef.createElement('button');
        promptButton.type = 'button';
        promptButton.className = 'lb-preloader__prompt';
        promptButton.dataset.role = 'start-prompt';
        promptButton.textContent = promptText;

        startEvents.forEach((type) => {
            const handler = handleEvent as EventListener;
            promptButton?.addEventListener(type, handler);
            promptListeners.push({ type, handler });
        });

        root.appendChild(promptButton);
        updateState('awaiting-interaction');
    };

    const prepare = () => {
        if (preparePromise) {
            return preparePromise;
        }

        if (disposed) {
            return Promise.resolve();
        }

        const run = (async () => {
            updateState('loading');

            try {
                await loadAssets((event) => {
                    if (disposed) {
                        return;
                    }
                    updateProgress(event);
                });

                if (progress.total === 0) {
                    updateProgress({ loaded: 1, total: 1 });
                }

                ensurePrompt();
            } catch (error) {
                fail(error);
            }
        })();

        preparePromise = run.catch((error) => {
            preparePromise = undefined;
            throw error;
        });

        return preparePromise;
    };

    const destroy = () => {
        if (disposed) {
            return;
        }

        disposed = true;
        removePrompt();
        if (root.parentElement === container) {
            root.remove();
        }
    };

    return {
        prepare,
        status: () => status,
        progress: () => ({ ...progress }),
        destroy,
    };
};
</file>

<file path="src/audio/index.ts">
export interface AudioBootstrapOptions {
    readonly enableMusic?: boolean;
    readonly enableSfx?: boolean;
}

export interface AudioSubsystem {
    readonly shutdown: () => void;
}

export function bootstrapAudio(_options: AudioBootstrapOptions = {}): AudioSubsystem {
    throw new Error('bootstrapAudio not implemented');
}
</file>

<file path="src/input/input-manager.ts">
/**
 * Input Manager Implementation
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Cross-platform input handling for paddle control and launch triggers
 */

import type { InputManager, InputDebugState, InputType, Vector2 } from './contracts';
import { PaddleLaunchManager } from './launch-manager';
import { normalizeMouseEvent, normalizeTouchEvent } from 'util/input-helpers';

export class GameInputManager implements InputManager {
    private container: HTMLElement | null = null;
    private canvas: HTMLCanvasElement | null = null;
    private mousePosition: Vector2 | null = null;
    private touchPosition: Vector2 | null = null;
    private keyboardState = new Map<string, boolean>();
    private activeInputs = new Set<InputType>();
    private launchManager = new PaddleLaunchManager();
    private previousPaddlePosition: Vector2 | null = null;
    private hasReceivedInput = false; // Track if user has moved mouse/touch since initialization

    initialize(container: HTMLElement): void {
        this.container = container;
        // Find the canvas element within the container
        this.canvas = container.querySelector('canvas') || null;

        // Clear any stale positions from before initialization
        this.mousePosition = null;
        this.touchPosition = null;
        this.hasReceivedInput = false;

        this.setupEventListeners();
    }

    private setupEventListeners(): void {
        if (!this.container) return;

        // Mouse events
        this.container.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.container.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.container.addEventListener('mouseup', this.handleMouseUp.bind(this));

        // Touch events
        this.container.addEventListener('touchstart', this.handleTouchStart.bind(this));
        this.container.addEventListener('touchmove', this.handleTouchMove.bind(this));
        this.container.addEventListener('touchend', this.handleTouchEnd.bind(this));

        // Keyboard events
        document.addEventListener('keydown', this.handleKeyDown.bind(this));
        document.addEventListener('keyup', this.handleKeyUp.bind(this));

        // Prevent context menu on right click
        this.container.addEventListener('contextmenu', (e) => e.preventDefault());
    }

    private handleMouseDown(event: MouseEvent): void {
        this.activeInputs.add('mouse');
        this.hasReceivedInput = true; // User has interacted

        if (this.canvas) {
            const normalized = normalizeMouseEvent(event, this.canvas);
            this.mousePosition = { x: normalized.x, y: normalized.y };
        } else {
            // Fallback: use raw client coordinates
            this.mousePosition = { x: event.clientX, y: event.clientY };
        }

        this.launchManager.triggerTapLaunch(this.mousePosition);
    }

    private handleMouseMove(event: MouseEvent): void {
        this.activeInputs.add('mouse');
        this.hasReceivedInput = true; // User has moved mouse

        if (this.canvas) {
            const normalized = normalizeMouseEvent(event, this.canvas);
            this.mousePosition = { x: normalized.x, y: normalized.y };
        } else {
            // Fallback: use raw client coordinates
            this.mousePosition = { x: event.clientX, y: event.clientY };
        }
    }

    private handleMouseUp(event: MouseEvent): void {
        // Mouse up doesn't remove from active inputs as mouse is still available
    }

    private handleTouchStart(event: TouchEvent): void {
        this.activeInputs.add('touch');
        this.hasReceivedInput = true; // User has touched

        if (event.touches.length > 0) {
            const touch = event.touches[0];

            if (this.canvas) {
                const normalized = normalizeTouchEvent(event, this.canvas);
                if (normalized.touches.length > 0) {
                    this.touchPosition = { x: normalized.touches[0].x, y: normalized.touches[0].y };
                    this.launchManager.triggerTapLaunch(this.touchPosition);
                }
            } else {
                // Fallback: use raw client coordinates
                this.touchPosition = { x: touch.clientX, y: touch.clientY };
                this.launchManager.triggerTapLaunch(this.touchPosition);
            }
        }
    }

    private handleTouchMove(event: TouchEvent): void {
        this.activeInputs.add('touch');
        this.hasReceivedInput = true; // User has moved touch

        if (event.touches.length > 0) {
            const touch = event.touches[0];

            if (this.canvas) {
                const normalized = normalizeTouchEvent(event, this.canvas);
                if (normalized.touches.length > 0) {
                    this.touchPosition = { x: normalized.touches[0].x, y: normalized.touches[0].y };
                }
            } else {
                // Fallback: use raw client coordinates
                this.touchPosition = { x: touch.clientX, y: touch.clientY };
            }
        }
    }

    private handleTouchEnd(event: TouchEvent): void {
        // Touch end doesn't remove from active inputs as touch is still available
    }

    private handleKeyDown(event: KeyboardEvent): void {
        this.activeInputs.add('keyboard');
        this.keyboardState.set(event.code, true);
    }

    private handleKeyUp(event: KeyboardEvent): void {
        this.keyboardState.set(event.code, false);
    }

    getPaddleTarget(): Vector2 | null {
        // Don't return mouse/touch position until user has actually moved after initialization
        if (!this.hasReceivedInput) {
            return null;
        }

        // Priority: mouse > touch > keyboard
        if (this.mousePosition) {
            return { ...this.mousePosition };
        }

        if (this.touchPosition) {
            return { ...this.touchPosition };
        }

        // Keyboard control - simulate left/right movement from arrow keys
        const leftPressed = this.keyboardState.get('ArrowLeft') || this.keyboardState.get('KeyA');
        const rightPressed = this.keyboardState.get('ArrowRight') || this.keyboardState.get('KeyD');

        if (leftPressed || rightPressed) {
            // For keyboard, we need the current paddle position to move relative to it
            // This would be passed in from the game loop
            // For now, return null - keyboard movement is handled in the paddle controller
            return null;
        }

        return null;
    }

    shouldLaunch(): boolean {
        return this.launchManager.isLaunchPending();
    }

    resetLaunchTrigger(): void {
        this.launchManager.reset();
    }

    /**
     * Check for launch based on paddle movement
     * @param currentPaddlePosition - Current paddle position
     * @returns True if launch should be triggered
     */
    checkMovementLaunch(currentPaddlePosition: Vector2): boolean {
        const shouldLaunch = this.launchManager.shouldTriggerLaunch(
            currentPaddlePosition,
            this.previousPaddlePosition,
            5 // movement threshold
        );

        this.previousPaddlePosition = { ...currentPaddlePosition };
        return shouldLaunch;
    }

    getDebugState(): InputDebugState {
        return {
            activeInputs: Array.from(this.activeInputs),
            mousePosition: this.mousePosition,
            keyboardPressed: Array.from(this.keyboardState.entries())
                .filter(([_, pressed]) => pressed)
                .map(([key, _]) => key),
            paddleTarget: this.getPaddleTarget(),
            launchPending: this.shouldLaunch(),
        };
    }

    destroy(): void {
        if (!this.container) return;

        // Remove all event listeners
        this.container.removeEventListener('mousedown', this.handleMouseDown.bind(this));
        this.container.removeEventListener('mousemove', this.handleMouseMove.bind(this));
        this.container.removeEventListener('mouseup', this.handleMouseUp.bind(this));
        this.container.removeEventListener('touchstart', this.handleTouchStart.bind(this));
        this.container.removeEventListener('touchmove', this.handleTouchMove.bind(this));
        this.container.removeEventListener('touchend', this.handleTouchEnd.bind(this));
        this.container.removeEventListener('contextmenu', (e) => e.preventDefault());

        document.removeEventListener('keydown', this.handleKeyDown.bind(this));
        document.removeEventListener('keyup', this.handleKeyUp.bind(this));

        this.launchManager.reset();
        this.activeInputs.clear();
        this.keyboardState.clear();
        this.container = null;
    }
}
</file>

<file path="src/physics/ball-launch.ts">
/**
 * Ball Launch Controller
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Applies launch velocity to balls and manages launch state
 */

import type { Ball, Vector2 } from './contracts';
import { Body, Vector } from 'matter-js';

export interface BallLaunchController {
    /**
     * Launch a ball with specified direction and speed
     * @param ball - Ball to launch
     * @param direction - Launch direction (normalized automatically)
     * @param speed - Launch speed (default: 8)
     */
    launch(ball: Ball, direction?: Vector2, speed?: number): void;

    /**
     * Check if ball can be launched (is attached)
     * @param ball - Ball to check
     * @returns True if ball is in launchable state
     */
    canLaunch(ball: Ball): boolean;

    /**
     * Get launch velocity for given direction and speed
     * @param direction - Launch direction
     * @param speed - Launch speed
     * @returns Velocity vector
     */
    calculateLaunchVelocity(direction: Vector2, speed: number): Vector2;

    /**
     * Get debug information about launch state
     * @param ball - Ball to inspect
     */
    getLaunchDebugInfo(ball: Ball): BallLaunchDebugInfo;
}

export interface BallLaunchDebugInfo {
    canLaunch: boolean;
    currentVelocity: Vector2;
    launchSpeed: number;
    lastLaunchDirection?: Vector2;
}

export class PhysicsBallLaunchController implements BallLaunchController {
    private readonly defaultLaunchSpeed = 8; // Consistent speed for Breakout-style game
    private lastLaunchDirection: Vector2 | null = null;

    launch(ball: Ball, direction: Vector2 = { x: 0, y: -1 }, speed = this.defaultLaunchSpeed): void {
        if (!this.canLaunch(ball)) {
            return;
        }

        // Detach ball from paddle if attached
        if (ball.isAttached) {
            // Detach will be handled by physics world in main.ts
            ball.isAttached = false;
        }

        // Calculate and apply launch velocity using setVelocity for consistent speed
        const normalized = Vector.normalise(direction as Vector);
        const velocity = Vector.mult(normalized, speed);
        Body.setVelocity(ball.physicsBody, velocity);

        this.lastLaunchDirection = { ...direction };
    }

    canLaunch(ball: Ball): boolean {
        // Ball can be launched if it's attached to paddle
        return ball.isAttached;
    }

    calculateLaunchVelocity(direction: Vector2, speed: number): Vector2 {
        // Normalize direction vector
        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y);

        if (length === 0) {
            // Default to upward if zero vector provided
            return { x: 0, y: -speed };
        }

        const normalizedX = direction.x / length;
        const normalizedY = direction.y / length;

        return {
            x: normalizedX * speed,
            y: normalizedY * speed,
        };
    }

    getLaunchDebugInfo(ball: Ball): BallLaunchDebugInfo {
        return {
            canLaunch: this.canLaunch(ball),
            currentVelocity: {
                x: ball.physicsBody.velocity.x,
                y: ball.physicsBody.velocity.y,
            },
            launchSpeed: this.defaultLaunchSpeed,
            lastLaunchDirection: this.lastLaunchDirection || undefined,
        };
    }
}
</file>

<file path="src/render/debug-overlay.ts">
/**
 * Input Debug Overlay
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Provides visual debugging overlay for input and paddle state
 */

import { Container, Graphics, Text, TextStyle } from 'pixi.js';
import type { GameInputManager } from 'input/input-manager';
import type { PaddleBodyController } from './paddle-body';
import type { BallAttachmentController } from 'physics/ball-attachment';

export interface DebugOverlayOptions {
    inputManager: GameInputManager;
    paddleController: PaddleBodyController;
    ballController: BallAttachmentController;
    paddle: any; // Paddle instance
    ball: any; // Ball instance
}

export class InputDebugOverlay {
    private container: Container;
    private textElements: Text[] = [];
    private graphics: Graphics;
    private options: DebugOverlayOptions;

    constructor(options: DebugOverlayOptions) {
        this.options = options;
        this.container = new Container();
        this.graphics = new Graphics();
        this.container.addChild(this.graphics);

        this.createTextElements();
        this.update();
    }

    private createTextElements(): void {
        const style = new TextStyle({
            fontFamily: 'monospace',
            fontSize: 12,
            fill: 0xffffff,
        });

        const labels = [
            'Input State',
            'Paddle Position',
            'Ball State',
            'Launch Status',
        ];

        labels.forEach((label, index) => {
            const text = new Text(label, style);
            text.x = 10;
            text.y = 10 + index * 20;
            this.textElements.push(text);
            this.container.addChild(text);
        });
    }

    update(): void {
        const inputState = this.options.inputManager.getDebugState();
        const paddleDebug = this.options.paddleController.getDebugInfo(this.options.paddle);
        const ballDebug = this.options.ballController.getDebugInfo(this.options.ball);

        // Update text elements
        if (this.textElements.length >= 4) {
            this.textElements[0].text = `Input: ${inputState.activeInputs.join(', ')} | Mouse: ${inputState.mousePosition ? `(${inputState.mousePosition.x}, ${inputState.mousePosition.y})` : 'none'} | Launch: ${inputState.launchPending}`;
            this.textElements[1].text = `Paddle: (${paddleDebug.position.x.toFixed(1)}, ${paddleDebug.position.y.toFixed(1)}) | Bounds: ${paddleDebug.bounds.x}-${paddleDebug.bounds.x + paddleDebug.bounds.width}`;
            this.textElements[2].text = `Ball: ${ballDebug.isAttached ? 'Attached' : 'Free'} | Pos: (${ballDebug.position.x.toFixed(1)}, ${ballDebug.position.y.toFixed(1)}) | Vel: (${ballDebug.velocity.x.toFixed(1)}, ${ballDebug.velocity.y.toFixed(1)})`;
            this.textElements[3].text = `Launch: ${inputState.launchPending ? 'Pending' : 'Ready'} | Offset: (${ballDebug.attachmentOffset.x.toFixed(1)}, ${ballDebug.attachmentOffset.y.toFixed(1)})`;
        }

        // Update graphics
        this.graphics.clear();

        // Draw paddle bounds
        this.graphics.setStrokeStyle({ width: 1, color: 0x00ff00, alpha: 0.5 });
        this.graphics.rect(
            paddleDebug.bounds.x,
            paddleDebug.bounds.y,
            paddleDebug.bounds.width,
            paddleDebug.bounds.height
        );
        this.graphics.stroke();

        // Draw paddle center
        this.graphics.setFillStyle({ color: 0x00ff00, alpha: 0.8 });
        this.graphics.circle(paddleDebug.position.x, paddleDebug.position.y, 3);
        this.graphics.fill();

        // Draw ball position
        this.graphics.setFillStyle({ color: 0xff0000, alpha: 0.8 });
        this.graphics.circle(ballDebug.position.x, ballDebug.position.y, 5);
        this.graphics.fill();

        // Draw attachment line if attached
        if (ballDebug.isAttached) {
            this.graphics.setStrokeStyle({ width: 2, color: 0xffff00, alpha: 0.8 });
            this.graphics.moveTo(paddleDebug.position.x, paddleDebug.position.y);
            this.graphics.lineTo(ballDebug.position.x, ballDebug.position.y);
            this.graphics.stroke();
        }

        // Draw input cursor position
        if (inputState.mousePosition) {
            this.graphics.setFillStyle({ color: 0x0000ff, alpha: 0.6 });
            this.graphics.circle(inputState.mousePosition.x, inputState.mousePosition.y, 4);
            this.graphics.fill();
        }
    }

    getContainer(): Container {
        return this.container;
    }

    destroy(): void {
        this.graphics.destroy();
        this.textElements.forEach(text => text.destroy());
        this.container.destroy();
    }
}
</file>

<file path="src/render/paddle-body.ts">
/**
 * Paddle Body Controller
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Implements paddle kinematic body with physics integration
 */

import type {
    PaddleController,
    Paddle,
    PaddleOptions,
    Vector2,
    Rectangle,
    BoundaryCollision,
    PaddleDebugInfo,
    InputState
} from './contracts';
import { createPhysicsWorld } from 'physics/world';

export class PaddleBodyController implements PaddleController {
    private physicsWorld = createPhysicsWorld();

    /**
     * Create a new paddle with physics body
     */
    createPaddle(initialPosition: Vector2, options: PaddleOptions = {}): Paddle {
        const width = options.width ?? 100;
        const height = options.height ?? 20;
        const speed = options.speed ?? 300;

        const physicsBody = this.physicsWorld.factory.paddle({
            position: initialPosition,
            size: { width, height },
        });

        return {
            id: `paddle-${Date.now()}`,
            physicsBody,
            width,
            height,
            speed,
            position: { ...initialPosition },
        };
    }

    /**
     * Update paddle position based on input
     */
    updatePaddle(paddle: Paddle, deltaTime: number, inputState: InputState): void {
        let targetX = paddle.position.x;

        // Handle keyboard input
        if (inputState.leftPressed) {
            targetX -= paddle.speed * deltaTime;
        }
        if (inputState.rightPressed) {
            targetX += paddle.speed * deltaTime;
        }

        // Handle mouse/touch input (takes precedence)
        if (inputState.mouseX !== undefined) {
            targetX = inputState.mouseX;
        } else if (inputState.touchX !== undefined) {
            targetX = inputState.touchX;
        }

        // Constrain to screen bounds (1280px width to match physics world)
        const halfWidth = paddle.width / 2;
        targetX = Math.max(halfWidth, Math.min(1280 - halfWidth, targetX));

        // Update physics body position
        paddle.physicsBody.position.x = targetX;
        paddle.physicsBody.position.y = paddle.position.y;

        // Update paddle state
        paddle.position.x = targetX;
    }

    /**
     * Set paddle position directly (for initialization or reset)
     */
    setPaddlePosition(paddle: Paddle, position: Vector2): void {
        // Constrain to screen bounds (1280px width to match physics world)
        const halfWidth = paddle.width / 2;
        const constrainedX = Math.max(halfWidth, Math.min(1280 - halfWidth, position.x));

        paddle.physicsBody.position.x = constrainedX;
        paddle.physicsBody.position.y = position.y;
        paddle.position.x = constrainedX;
        paddle.position.y = position.y;
    }

    /**
     * Get paddle bounds for collision detection
     */
    getPaddleBounds(paddle: Paddle): Rectangle {
        return {
            x: paddle.position.x - paddle.width / 2,
            y: paddle.position.y - paddle.height / 2,
            width: paddle.width,
            height: paddle.height,
        };
    }

    /**
     * Get paddle center position
     */
    getPaddleCenter(paddle: Paddle): Vector2 {
        return { ...paddle.position };
    }

    /**
     * Check if paddle is at screen boundary
     */
    checkBoundaryCollision(paddle: Paddle, screenWidth: number): BoundaryCollision {
        const halfWidth = paddle.width / 2;
        return {
            left: paddle.position.x - halfWidth <= 0,
            right: paddle.position.x + halfWidth >= screenWidth,
        };
    }

    /**
     * Get paddle debug information
     */
    getDebugInfo(paddle: Paddle): PaddleDebugInfo {
        return {
            position: { ...paddle.position },
            velocity: { x: 0, y: 0 }, // Paddle is kinematic, no velocity
            bounds: this.getPaddleBounds(paddle),
            physicsBodyId: paddle.physicsBody.id,
            inputState: {
                leftPressed: false,
                rightPressed: false,
                launchRequested: false,
            }, // This would need to be passed in from actual input state
        };
    }
}
</file>

<file path="src/util/index.ts">
export type Noop = () => void;

export const noop: Noop = () => undefined;

export * from './geometry';
export * from './input-helpers';
</file>

<file path="src/util/input-helpers.ts">
/**
 * Input Event Normalization Helpers
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Normalize browser input events into game input state
 */

import type { Vector2, InputState, InputType } from 'types/input';

/**
 * Mouse event data
 */
export interface MouseEventData {
    x: number;
    y: number;
    button: 'left' | 'right' | 'middle';
    pressed: boolean;
}

/**
 * Keyboard event data
 */
export interface KeyboardEventData {
    key: string;
    pressed: boolean;
}

/**
 * Touch event data
 */
export interface TouchEventData {
    touches: readonly Vector2[];
}

/**
 * Normalize mouse event to game coordinates
 */
export function normalizeMouseEvent(event: MouseEvent, canvas: HTMLCanvasElement): MouseEventData {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    return {
        x: (event.clientX - rect.left) * scaleX,
        y: (event.clientY - rect.top) * scaleY,
        button: getMouseButton(event.button),
        pressed: event.type === 'mousedown',
    };
}

/**
 * Normalize keyboard event
 */
export function normalizeKeyboardEvent(event: KeyboardEvent): KeyboardEventData {
    return {
        key: event.code, // Use code for physical key location
        pressed: event.type === 'keydown',
    };
}

/**
 * Normalize touch event to game coordinates
 */
export function normalizeTouchEvent(event: TouchEvent, canvas: HTMLCanvasElement): TouchEventData {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    const touches: Vector2[] = [];
    for (let i = 0; i < event.touches.length; i++) {
        const touch = event.touches[i];
        touches.push({
            x: (touch.clientX - rect.left) * scaleX,
            y: (touch.clientY - rect.top) * scaleY,
        });
    }

    return { touches };
}

/**
 * Convert normalized input events to game input state
 */
export function eventsToInputState(
    mouseEvent?: MouseEventData,
    keyboardEvents: readonly KeyboardEventData[] = [],
    touchEvent?: TouchEventData
): InputState {
    // Check keyboard input
    const leftPressed = keyboardEvents.some(e => e.pressed && (e.key === 'ArrowLeft' || e.key === 'KeyA'));
    const rightPressed = keyboardEvents.some(e => e.pressed && (e.key === 'ArrowRight' || e.key === 'KeyD'));

    // Get mouse position
    const mouseX = mouseEvent?.x;

    // Get touch position (use first touch)
    const touchX = touchEvent?.touches[0]?.x;

    // Launch requested if space pressed or screen tapped
    const spacePressed = keyboardEvents.some(e => e.pressed && e.key === 'Space');
    const screenTapped = touchEvent !== undefined || (mouseEvent !== undefined && mouseEvent.pressed && mouseEvent.button === 'left');

    return {
        leftPressed,
        rightPressed,
        mouseX,
        touchX,
        launchRequested: spacePressed || screenTapped,
    };
}

/**
 * Get active input types from current events
 */
export function getActiveInputTypes(
    mouseEvent?: MouseEventData,
    keyboardEvents: readonly KeyboardEventData[] = [],
    touchEvent?: TouchEventData
): readonly InputType[] {
    const activeInputs: InputType[] = [];

    if (mouseEvent) activeInputs.push('mouse');
    if (keyboardEvents.length > 0) activeInputs.push('keyboard');
    if (touchEvent) activeInputs.push('touch');

    return activeInputs;
}

/**
 * Convert mouse button number to string
 */
function getMouseButton(button: number): 'left' | 'right' | 'middle' {
    switch (button) {
        case 0: return 'left';
        case 1: return 'middle';
        case 2: return 'right';
        default: return 'left';
    }
}

/**
 * Check if input state indicates paddle movement
 */
export function hasPaddleMovement(inputState: InputState): boolean {
    return inputState.leftPressed || inputState.rightPressed || inputState.mouseX !== undefined || inputState.touchX !== undefined;
}

/**
 * Get target paddle position from input state
 */
export function getPaddleTarget(inputState: InputState, screenWidth: number, paddleWidth: number): Vector2 | null {
    // Keyboard input takes precedence
    if (inputState.leftPressed) {
        return { x: paddleWidth / 2, y: 0 }; // Left edge
    }
    if (inputState.rightPressed) {
        return { x: screenWidth - paddleWidth / 2, y: 0 }; // Right edge
    }

    // Mouse/touch input
    const inputX = inputState.mouseX ?? inputState.touchX;
    if (inputX !== undefined) {
        return { x: Math.max(paddleWidth / 2, Math.min(screenWidth - paddleWidth / 2, inputX)), y: 0 };
    }

    return null;
}
</file>

<file path="src/util/log.ts">
export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export interface LogEntry {
    readonly level: LogLevel;
    readonly subsystem: string;
    readonly message: string;
    readonly timestamp: number;
    readonly context?: Record<string, unknown>;
}

export type LogWriter = (entry: LogEntry) => void;
export type NowFn = () => number;

const toIsoTimestamp = (timestamp: number): string => new Date(timestamp).toISOString();

const bindConsole = <Key extends LogLevel>(method: Key): ((...parts: unknown[]) => void) => {
    const { console } = globalThis;
    const fallback = console.log.bind(console);
    const candidate = console[method]?.bind(console);
    return (candidate ?? fallback) as (...parts: unknown[]) => void;
};

const consoleSinks: Record<LogLevel, (...parts: unknown[]) => void> = {
    debug: bindConsole('debug'),
    info: bindConsole('info'),
    warn: bindConsole('warn'),
    error: bindConsole('error'),
};

export const defaultLogWriter: LogWriter = (entry) => {
    const sink = consoleSinks[entry.level];
    const prefix = `[${entry.level.toUpperCase()}][${entry.subsystem}]`;
    const timestamp = toIsoTimestamp(entry.timestamp);

    if (entry.context && Object.keys(entry.context).length > 0) {
        sink(`${timestamp} ${prefix} ${entry.message}`, entry.context);
        return;
    }

    sink(`${timestamp} ${prefix} ${entry.message}`);
};

export interface Logger {
    readonly debug: (message: string, context?: Record<string, unknown>) => void;
    readonly info: (message: string, context?: Record<string, unknown>) => void;
    readonly warn: (message: string, context?: Record<string, unknown>) => void;
    readonly error: (message: string, context?: Record<string, unknown>) => void;
    readonly child: (subsystem: string) => Logger;
}

export interface LoggerOptions {
    readonly writer?: LogWriter;
    readonly now?: NowFn;
}

const sanitizeSubsystem = (subsystem: string): string => subsystem.trim() || 'unknown';

const createLoggerForLevel = (
    level: LogLevel,
    subsystem: string,
    writer: LogWriter,
    now: NowFn,
): ((message: string, context?: Record<string, unknown>) => void) => {
    return (message, context) => {
        const entry: LogEntry = {
            level,
            subsystem,
            message,
            context,
            timestamp: now(),
        };
        writer(entry);
    };
};

export const createLogger = (subsystem: string, options: LoggerOptions = {}): Logger => {
    const writer = options.writer ?? defaultLogWriter;
    const now = options.now ?? Date.now;
    const normalized = sanitizeSubsystem(subsystem);

    const debug = createLoggerForLevel('debug', normalized, writer, now);
    const info = createLoggerForLevel('info', normalized, writer, now);
    const warn = createLoggerForLevel('warn', normalized, writer, now);
    const error = createLoggerForLevel('error', normalized, writer, now);

    const child: Logger['child'] = (suffix) => {
        const combined = `${normalized}:${sanitizeSubsystem(suffix)}`;
        return createLogger(combined, { writer, now });
    };

    return {
        debug,
        info,
        warn,
        error,
        child,
    };
};

export const rootLogger = createLogger('app');
</file>

<file path="tests/integration/paddle-ball-flow.spec.ts">
/**
 * Paddle Ball Flow Integration Test
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: End-to-end test of paddle control and ball launch mechanics
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { GameInputManager } from 'input/input-manager';
import { PaddleBodyController } from 'render/paddle-body';
import { BallAttachmentController } from 'physics/ball-attachment';
import { PhysicsBallLaunchController } from 'physics/ball-launch';
import { createPhysicsWorld } from 'physics/world';

describe('Paddle Ball Flow Integration', () => {
    let inputManager: GameInputManager;
    let paddleController: PaddleBodyController;
    let ballController: BallAttachmentController;
    let launchController: PhysicsBallLaunchController;
    let physicsWorld: ReturnType<typeof createPhysicsWorld>;
    let paddle: any;
    let ball: any;
    let mockContainer: HTMLElement;

    beforeEach(() => {
        mockContainer = document.createElement('div');
        mockContainer.style.width = '800px';
        mockContainer.style.height = '600px';
        document.body.appendChild(mockContainer);

        inputManager = new GameInputManager();
        paddleController = new PaddleBodyController();
        ballController = new BallAttachmentController();
        launchController = new PhysicsBallLaunchController();
        physicsWorld = createPhysicsWorld();

        inputManager.initialize(mockContainer);

        // Create paddle
        paddle = paddleController.createPaddle(
            { x: 400, y: 350 },
            { width: 100, height: 20, speed: 300 }
        );
        physicsWorld.add(paddle.physicsBody);

        // Create ball attached to paddle
        ball = ballController.createAttachedBall(
            paddleController.getPaddleCenter(paddle),
            { radius: 10, restitution: 0.98 }
        );
        physicsWorld.add(ball.physicsBody);
    });

    afterEach(() => {
        inputManager.destroy();
        physicsWorld.dispose();
        document.body.removeChild(mockContainer);
    });

    describe('Initial State', () => {
        it('should start with ball attached to paddle', () => {
            expect(ballController.isAttached(ball)).toBe(true);
            expect(ball.physicsBody.velocity.x).toBe(0);
            expect(ball.physicsBody.velocity.y).toBe(0);
        });

        it('should have paddle at initial position', () => {
            const center = paddleController.getPaddleCenter(paddle);
            expect(center.x).toBe(400);
            expect(center.y).toBe(350);
        });

        it('should have no launch pending initially', () => {
            expect(inputManager.shouldLaunch()).toBe(false);
        });
    });

    describe('Paddle Movement', () => {
        it('should move paddle with mouse input', () => {
            // Move mouse
            mockContainer.dispatchEvent(new MouseEvent('mousemove', {
                clientX: 500,
                clientY: 350,
                bubbles: true,
            }));

            // Update paddle
            const paddleTarget = inputManager.getPaddleTarget();
            if (paddleTarget) {
                paddleController.updatePaddle(paddle, 1 / 60, {
                    leftPressed: false,
                    rightPressed: false,
                    mouseX: paddleTarget.x,
                    touchX: undefined,
                    launchRequested: false,
                });
            }

            // Ball should follow paddle
            ballController.updateAttachment(ball, paddleController.getPaddleCenter(paddle));

            const paddleCenter = paddleController.getPaddleCenter(paddle);
            expect(paddleCenter.x).toBe(500);
            expect(ballController.isAttached(ball)).toBe(true);
        });

        it('should constrain paddle within boundaries', () => {
            // Try to move paddle out of bounds
            mockContainer.dispatchEvent(new MouseEvent('mousemove', {
                clientX: 10, // Out of bounds
                clientY: 350,
                bubbles: true,
            }));

            const paddleTarget = inputManager.getPaddleTarget();
            if (paddleTarget) {
                paddleController.updatePaddle(paddle, 1 / 60, {
                    leftPressed: false,
                    rightPressed: false,
                    mouseX: paddleTarget.x,
                    touchX: undefined,
                    launchRequested: false,
                });
            }

            const paddleCenter = paddleController.getPaddleCenter(paddle);
            expect(paddleCenter.x).toBe(50); // Constrained to half width
        });
    });

    describe('Ball Launch Triggers', () => {
        it('should launch ball on mouse click', () => {
            // Click to launch
            mockContainer.dispatchEvent(new MouseEvent('mousedown', {
                clientX: 400,
                clientY: 350,
                bubbles: true,
            }));

            // Process launch
            if (inputManager.shouldLaunch()) {
                launchController.launch(ball);
                inputManager.resetLaunchTrigger();
            }

            expect(ballController.isAttached(ball)).toBe(false);
            expect(ball.physicsBody.velocity.y).toBeLessThan(0); // Moving upward
        });

        it('should launch ball on paddle movement', () => {
            // Move paddle significantly
            mockContainer.dispatchEvent(new MouseEvent('mousemove', {
                clientX: 400,
                clientY: 350,
                bubbles: true,
            }));

            // Simulate paddle movement detection (this would happen in the game loop)
            const hasMovement = (inputManager as any).launchManager.shouldTriggerLaunch(
                { x: 410, y: 350 },
                { x: 400, y: 350 },
                5
            );

            if (hasMovement) {
                launchController.launch(ball);
            }

            expect(ballController.isAttached(ball)).toBe(false);
            expect(ball.physicsBody.velocity.y).toBeLessThan(0);
        });
    });

    describe('Post-Launch Behavior', () => {
        it('should allow ball to move freely after launch', () => {
            // Launch ball
            launchController.launch(ball);

            // Step physics
            physicsWorld.step(1 / 60);

            const initialPosition = { ...ball.physicsBody.position };

            // Step more physics
            for (let i = 0; i < 10; i++) {
                physicsWorld.step(1 / 60);
            }

            const finalPosition = ball.physicsBody.position;
            const deltaX = Math.abs(finalPosition.x - initialPosition.x);
            const deltaY = Math.abs(finalPosition.y - initialPosition.y);

            expect(deltaX + deltaY).toBeGreaterThan(1); // Should have moved
        });

        it('should maintain ball physics after launch', () => {
            const initialVelocity = { ...ball.physicsBody.velocity };

            launchController.launch(ball);

            // Step physics multiple times
            for (let i = 0; i < 60; i++) { // 1 second
                physicsWorld.step(1 / 60);
            }

            const finalVelocity = ball.physicsBody.velocity;
            const speedChange = Math.abs(
                Math.sqrt(finalVelocity.x ** 2 + finalVelocity.y ** 2) -
                Math.sqrt(initialVelocity.x ** 2 + initialVelocity.y ** 2)
            );

            expect(speedChange).toBeLessThan(50); // Should maintain most velocity
        });
    });

    describe('Reset and Replay', () => {
        it('should reset ball to attached state', () => {
            // Launch ball
            launchController.launch(ball);
            expect(ballController.isAttached(ball)).toBe(false);

            // Reset to attached
            ballController.resetToAttached(ball, paddleController.getPaddleCenter(paddle));
            expect(ballController.isAttached(ball)).toBe(true);
            expect(ball.physicsBody.velocity.x).toBe(0);
            expect(ball.physicsBody.velocity.y).toBe(0);
        });

        it('should handle multiple launch cycles', () => {
            const paddleCenter = paddleController.getPaddleCenter(paddle);

            // Cycle 1
            launchController.launch(ball);
            expect(ballController.isAttached(ball)).toBe(false);

            ballController.resetToAttached(ball, paddleCenter);
            expect(ballController.isAttached(ball)).toBe(true);

            // Cycle 2
            launchController.launch(ball, { x: 0, y: -1 });
            expect(ballController.isAttached(ball)).toBe(false);

            ballController.resetToAttached(ball, paddleCenter);
            expect(ballController.isAttached(ball)).toBe(true);
        });
    });

    describe('Cross-Platform Input', () => {
        it('should handle touch input', () => {
            const touchEvent = new TouchEvent('touchstart', {
                touches: [
                    new Touch({
                        identifier: 1,
                        target: mockContainer,
                        clientX: 450,
                        clientY: 375,
                    }),
                ],
                bubbles: true,
            });

            mockContainer.dispatchEvent(touchEvent);

            expect(inputManager.shouldLaunch()).toBe(true);
        });

        it('should handle keyboard input', () => {
            document.dispatchEvent(new KeyboardEvent('keydown', { code: 'ArrowLeft' }));

            const debugState = inputManager.getDebugState();
            expect(debugState.keyboardPressed).toContain('ArrowLeft');
        });
    });

    describe('Integration Flow', () => {
        it('should complete full paddle-ball interaction cycle', () => {
            // 1. Initial state
            expect(ballController.isAttached(ball)).toBe(true);

            // 2. Move paddle
            mockContainer.dispatchEvent(new MouseEvent('mousemove', {
                clientX: 450,
                clientY: 350,
                bubbles: true,
            }));

            const paddleTarget = inputManager.getPaddleTarget();
            if (paddleTarget) {
                paddleController.updatePaddle(paddle, 1 / 60, {
                    leftPressed: false,
                    rightPressed: false,
                    mouseX: paddleTarget.x,
                    touchX: undefined,
                    launchRequested: false,
                });
            }

            ballController.updateAttachment(ball, paddleController.getPaddleCenter(paddle));

            expect(paddleController.getPaddleCenter(paddle).x).toBe(450);
            expect(ballController.isAttached(ball)).toBe(true);

            // 3. Launch ball
            mockContainer.dispatchEvent(new MouseEvent('mousedown', {
                clientX: 450,
                clientY: 350,
                bubbles: true,
            }));

            if (inputManager.shouldLaunch()) {
                launchController.launch(ball);
                inputManager.resetLaunchTrigger();
            }

            expect(ballController.isAttached(ball)).toBe(false);
            expect(ball.physicsBody.velocity.y).toBeLessThan(0);

            // 4. Ball moves freely
            physicsWorld.step(1 / 60);
            const postLaunchPosition = { ...ball.physicsBody.position };

            physicsWorld.step(1 / 60);
            const newPosition = ball.physicsBody.position;

            expect(newPosition.x).not.toBe(postLaunchPosition.x);
            expect(newPosition.y).not.toBe(postLaunchPosition.y);
        });
    });
});
</file>

<file path="tests/unit/app/state.spec.ts">
import { describe, expect, it } from 'vitest';
import { createEventBus } from '@app/events';
import { createGameSessionManager, type GameSessionSnapshot } from '@app/state';

interface FakeClock {
    readonly now: () => number;
    readonly tick: (deltaMs: number) => void;
}

const createFakeClock = (start = 0): FakeClock => {
    let current = start;
    return {
        now: () => current,
        tick: (deltaMs) => {
            current += deltaMs;
        },
    };
};

describe('createGameSessionManager', () => {
    const createSnapshot = (overrides?: Partial<Parameters<typeof createGameSessionManager>[0]>) => {
        const clock = createFakeClock();
        const manager = createGameSessionManager({
            sessionId: 'session-001',
            now: clock.now,
            initialLives: 3,
            ...overrides,
        });
        return { manager, clock } as const;
    };

    const expectHud = (snapshot: GameSessionSnapshot) => snapshot.hud;

    it('starts pending with baseline scoreboard values', () => {
        const { manager } = createSnapshot();

        const snapshot = manager.snapshot();

        expect(snapshot.status).toBe('pending');
        expect(snapshot.score).toBe(0);
        expect(snapshot.livesRemaining).toBe(3);
        expect(snapshot.round).toBe(1);
        expect(snapshot.brickRemaining).toBe(0);
        expect(snapshot.brickTotal).toBe(0);

        const hud = expectHud(snapshot);
        expect(hud).toMatchObject({
            score: 0,
            lives: 3,
            round: 1,
            brickRemaining: 0,
            brickTotal: 0,
            momentum: {
                volleyLength: 0,
                speedPressure: 0,
                brickDensity: 1,
                comboHeat: 0,
            },
            audio: {
                scene: 'calm',
                nextScene: null,
                barCountdown: 0,
            },
        });
    });

    it('enters active state when a round starts and tracks brick inventory', () => {
        const { manager, clock } = createSnapshot();

        manager.startRound({ breakableBricks: 12 });
        clock.tick(500);

        const snapshot = manager.snapshot();
        expect(snapshot.status).toBe('active');
        expect(snapshot.round).toBe(1);
        expect(snapshot.elapsedTimeMs).toBe(500);

        const hud = expectHud(snapshot);
        expect(hud.brickTotal).toBe(12);
        expect(hud.brickRemaining).toBe(12);
        expect(hud.prompts[0]).toMatchObject({ id: 'round-active' });
    });

    it('records brick breaks by awarding score and reducing remaining brick count', () => {
        const { manager } = createSnapshot();

        manager.startRound({ breakableBricks: 3 });
        manager.recordBrickBreak({ points: 150 });
        manager.recordBrickBreak({ points: 200 });

        const snapshot = manager.snapshot();

        expect(snapshot.score).toBe(350);
        expect(snapshot.brickRemaining).toBe(1);

        const hud = expectHud(snapshot);
        expect(hud.score).toBe(350);
        expect(hud.brickRemaining).toBe(1);
        expect(hud.momentum.brickDensity).toBeCloseTo(1 / 3, 5);
    });

    it('marks the round complete when all bricks are cleared', () => {
        const clock = createFakeClock();
        const manager = createGameSessionManager({ sessionId: 'session-002', now: clock.now });

        manager.startRound({ breakableBricks: 2 });
        manager.recordBrickBreak({ points: 100 });
        clock.tick(1000);
        manager.recordBrickBreak({ points: 250 });
        clock.tick(500);
        manager.completeRound();

        const snapshot = manager.snapshot();

        expect(snapshot.status).toBe('completed');
        expect(snapshot.brickRemaining).toBe(0);
        expect(snapshot.lastOutcome).toMatchObject({
            result: 'win',
            round: 1,
            scoreAwarded: 350,
            durationMs: 1500,
        });

        const hud = expectHud(snapshot);
        expect(hud.prompts[0]).toMatchObject({ id: 'round-complete' });
    });

    it('emits brick break events with scoring details when available', () => {
        const bus = createEventBus();
        const publishSpy: unknown[] = [];
        bus.subscribe('BrickBreak', (event) => {
            publishSpy.push(event);
        });

        const manager = createGameSessionManager({
            sessionId: 'session-emit-1',
            eventBus: bus,
        });

        manager.startRound({ breakableBricks: 1 });
        manager.recordBrickBreak({
            points: 125,
            event: {
                row: 2,
                col: 5,
                velocity: 9.2,
                brickType: 'standard',
            },
        });

        expect(publishSpy).toHaveLength(1);
        const [event] = publishSpy;
        expect(event).toMatchObject({
            type: 'BrickBreak',
            payload: {
                sessionId: 'session-emit-1',
                row: 2,
                col: 5,
                velocity: 9.2,
                brickType: 'standard',
                comboHeat: expect.any(Number),
            },
            timestamp: expect.any(Number),
        });
    });

    it('emits round completion event when a round finishes', () => {
        const bus = createEventBus();
        const roundEvents: unknown[] = [];
        bus.subscribe('RoundCompleted', (event) => {
            roundEvents.push(event);
        });

        const clock = createFakeClock();
        const manager = createGameSessionManager({
            sessionId: 'session-emit-2',
            now: clock.now,
            eventBus: bus,
        });

        manager.startRound({ breakableBricks: 1 });
        clock.tick(250);
        manager.recordBrickBreak({ points: 50 });
        clock.tick(500);
        manager.completeRound();

        expect(roundEvents).toHaveLength(1);
        const [event] = roundEvents;
        expect(event).toMatchObject({
            type: 'RoundCompleted',
            payload: {
                sessionId: 'session-emit-2',
                round: 1,
                scoreAwarded: 50,
                durationMs: 750,
            },
            timestamp: expect.any(Number),
        });
    });

    it('transitions to failed when all lives are lost', () => {
        const clock = createFakeClock();
        const manager = createGameSessionManager({ sessionId: 'session-003', now: clock.now, initialLives: 2 });

        manager.startRound({ breakableBricks: 5 });
        manager.recordLifeLost('ball-drop');
        clock.tick(750);
        manager.recordLifeLost('ball-drop');

        const snapshot = manager.snapshot();

        expect(snapshot.status).toBe('failed');
        expect(snapshot.livesRemaining).toBe(0);
        expect(snapshot.lastOutcome).toMatchObject({
            result: 'loss',
            round: 1,
            cause: 'ball-drop',
            durationMs: 750,
        });

        const hud = expectHud(snapshot);
        expect(hud.lives).toBe(0);
        expect(hud.prompts[0]).toMatchObject({ id: 'round-failed', severity: 'error' });
    });
});
</file>

<file path="tests/unit/audio/mocks.ts">
import { vi } from 'vitest';

export interface ToneMockContext {
    readonly transport: {
        readonly schedule: ReturnType<typeof vi.fn>;
        readonly scheduleOnce: ReturnType<typeof vi.fn>;
        readonly clear: ReturnType<typeof vi.fn>;
        readonly cancel: ReturnType<typeof vi.fn>;
        readonly start: ReturnType<typeof vi.fn>;
        readonly stop: ReturnType<typeof vi.fn>;
        readonly seconds: number;
    };
    readonly advanceBy: (milliseconds: number) => void;
    readonly now: () => number;
    readonly restore: () => void;
}

export const installToneMock = (): ToneMockContext => {
    type ScheduledCallback = {
        id: number;
        at: number;
        callback: (scheduledTime: number) => void;
    };

    let nowSeconds = 0;
    const scheduled: ScheduledCallback[] = [];

    const schedule = vi.fn((callback: (scheduledTime: number) => void, at: number | string) => {
        const asSeconds = typeof at === 'number' ? at : parseFloat(String(at));
        const entry: ScheduledCallback = {
            id: scheduled.length,
            at: asSeconds,
            callback,
        };
        scheduled.push(entry);
        return entry.id;
    });

    const scheduleOnce = vi.fn((callback: (scheduledTime: number) => void, at: number | string) => {
        return schedule(callback, at);
    });

    const clear = vi.fn((id: number) => {
        const index = scheduled.findIndex((item) => item.id === id);
        if (index !== -1) {
            scheduled.splice(index, 1);
        }
    });

    const cancel = vi.fn(() => {
        scheduled.length = 0;
    });

    const start = vi.fn();
    const stop = vi.fn();

    const transportCore = {
        schedule: schedule as ReturnType<typeof vi.fn>,
        scheduleOnce: scheduleOnce as ReturnType<typeof vi.fn>,
        clear: clear as ReturnType<typeof vi.fn>,
        cancel: cancel as ReturnType<typeof vi.fn>,
        start: start as ReturnType<typeof vi.fn>,
        stop: stop as ReturnType<typeof vi.fn>,
    } as Record<string, ReturnType<typeof vi.fn>>;

    Object.defineProperty(transportCore, 'seconds', {
        get: () => nowSeconds,
    });

    const transport = transportCore as unknown as ToneMockContext['transport'];

    vi.doMock('tone', () => ({
        Transport: transport,
        now: () => nowSeconds,
        Destination: {
            volume: {
                value: 0,
            },
        },
    }));

    const advanceBy = (milliseconds: number): void => {
        nowSeconds += milliseconds / 1000;

        for (const entry of [...scheduled]) {
            if (entry.at <= nowSeconds) {
                entry.callback(nowSeconds);
                const index = scheduled.findIndex((item) => item.id === entry.id);
                if (index !== -1) {
                    scheduled.splice(index, 1);
                }
            }
        }
    };

    const restore = () => {
        vi.resetModules();
        vi.doUnmock('tone');
    };

    return {
        transport,
        advanceBy,
        now: () => nowSeconds,
        restore,
    };
};
</file>

<file path="tests/unit/audio/sfx.spec.ts">
import { afterAll, beforeAll, describe, expect, it } from 'vitest';
import { createEventBus } from '@app/events';
import { installToneMock, type ToneMockContext } from './mocks';

interface RecordedTrigger {
    readonly id: string;
    readonly time: number;
    readonly gain: number;
    readonly detune: number;
    readonly pan: number;
    readonly source: {
        readonly event: string;
        readonly row: number;
        readonly velocity: number;
    };
}

describe('createSfxRouter', () => {
    const lookAheadMs = 80;
    let tone: ToneMockContext;
    let createToneScheduler: any;
    let createSfxRouter: any;

    beforeAll(async () => {
        tone = installToneMock();
        ({ createToneScheduler } = await import('audio/scheduler'));
        ({ createSfxRouter } = await import('audio/sfx'));
    });

    afterAll(() => {
        tone.restore();
    });

    it('schedules brick-break SFX callbacks within the latency budget', () => {
        const bus = createEventBus();
        const triggers: RecordedTrigger[] = [];

        const scheduler = createToneScheduler({
            lookAheadMs,
            now: tone.now,
            schedule: tone.transport.scheduleOnce as unknown as (callback: (time: number) => void, at: number) => number,
            clear: tone.transport.clear as unknown as (id: number) => void,
            cancel: tone.transport.cancel as unknown as (time?: number) => void,
        });

        const router = createSfxRouter({
            bus,
            scheduler,
            trigger: (descriptor: RecordedTrigger) => {
                triggers.push(descriptor);
            },
        });

        const payload = {
            sessionId: 'session-001',
            row: 3,
            col: 4,
            velocity: 9.4,
            brickType: 'standard' as const,
            comboHeat: 7,
        };

        const publishTime = tone.now();
        bus.publish('BrickBreak', payload, publishTime * 1000);

        expect(tone.transport.scheduleOnce).toHaveBeenCalledTimes(1);
        const [scheduledCallback, scheduledAt] = tone.transport.scheduleOnce.mock.calls[0] as [
            (scheduledTime: number) => void,
            number,
        ];

        expect(typeof scheduledCallback).toBe('function');
        expect(scheduledAt).toBeGreaterThan(publishTime);
        expect(scheduledAt - publishTime).toBeLessThanOrEqual(lookAheadMs / 1000);

        tone.advanceBy(lookAheadMs);

        expect(triggers).toHaveLength(1);
        const [firstTrigger] = triggers;

        expect(firstTrigger.id).toContain('brick');
        expect(firstTrigger.time).toBeCloseTo(scheduledAt, 6);
        expect(firstTrigger.gain).toBeGreaterThan(0.4);
        expect(firstTrigger.gain).toBeLessThanOrEqual(1);
        expect(firstTrigger.source).toMatchObject({
            event: 'BrickBreak',
            row: payload.row,
            velocity: payload.velocity,
        });

        router.dispose();
        scheduler.dispose();
    });
});
</file>

<file path="tests/unit/input/contracts.spec.ts">
/**
 * Input Contracts Test Suite
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Test the input contracts and interfaces
 */

import { describe, it, expect } from 'vitest';
import type { InputManager, InputDebugState, InputType, Vector2 } from 'input/contracts';

describe('Input Contracts', () => {
    describe('InputManager Interface', () => {
        it('should define required methods', () => {
            // Type-only test - ensures interface compiles correctly
            const inputManager: InputManager = {
                initialize: () => { },
                getPaddleTarget: () => null,
                shouldLaunch: () => false,
                resetLaunchTrigger: () => { },
                getDebugState: () => ({} as InputDebugState),
                destroy: () => { },
            };

            expect(inputManager).toBeDefined();
            expect(typeof inputManager.initialize).toBe('function');
            expect(typeof inputManager.getPaddleTarget).toBe('function');
            expect(typeof inputManager.shouldLaunch).toBe('function');
            expect(typeof inputManager.resetLaunchTrigger).toBe('function');
            expect(typeof inputManager.getDebugState).toBe('function');
            expect(typeof inputManager.destroy).toBe('function');
        });
    });

    describe('InputDebugState Interface', () => {
        it('should define debug state properties', () => {
            const debugState: InputDebugState = {
                activeInputs: ['mouse', 'keyboard'] as readonly InputType[],
                mousePosition: { x: 100, y: 200 },
                keyboardPressed: ['ArrowLeft', 'Space'] as readonly string[],
                paddleTarget: { x: 300, y: 400 },
                launchPending: true,
            };

            expect(debugState.activeInputs).toEqual(['mouse', 'keyboard']);
            expect(debugState.mousePosition).toEqual({ x: 100, y: 200 });
            expect(debugState.keyboardPressed).toEqual(['ArrowLeft', 'Space']);
            expect(debugState.paddleTarget).toEqual({ x: 300, y: 400 });
            expect(debugState.launchPending).toBe(true);
        });

        it('should allow null values for optional properties', () => {
            const debugState: InputDebugState = {
                activeInputs: [] as readonly InputType[],
                mousePosition: null,
                keyboardPressed: [] as readonly string[],
                paddleTarget: null,
                launchPending: false,
            };

            expect(debugState.mousePosition).toBeNull();
            expect(debugState.paddleTarget).toBeNull();
            expect(debugState.launchPending).toBe(false);
        });
    });

    describe('InputType Type', () => {
        it('should accept valid input types', () => {
            const types: InputType[] = ['mouse', 'keyboard', 'touch'];
            expect(types).toHaveLength(3);
            expect(types).toContain('mouse');
            expect(types).toContain('keyboard');
            expect(types).toContain('touch');
        });
    });

    describe('Vector2 Interface', () => {
        it('should define 2D vector properties', () => {
            const vector: Vector2 = { x: 10, y: 20 };
            expect(vector.x).toBe(10);
            expect(vector.y).toBe(20);
        });
    });
});
</file>

<file path="tests/unit/input/input-normalization.spec.ts">
/**
 * Input Normalization Test Suite
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Test input normalization across mouse, keyboard, and touch
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { GameInputManager } from 'input/input-manager';

describe('Input Normalization', () => {
    let inputManager: GameInputManager;
    let mockContainer: HTMLElement;

    beforeEach(() => {
        mockContainer = document.createElement('div');
        mockContainer.style.width = '800px';
        mockContainer.style.height = '600px';
        document.body.appendChild(mockContainer);

        inputManager = new GameInputManager();
        inputManager.initialize(mockContainer);
    });

    afterEach(() => {
        inputManager.destroy();
        document.body.removeChild(mockContainer);
    });

    describe('Mouse Input', () => {
        it('should normalize mouse position to paddle target', () => {
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: 400,
                clientY: 350,
                bubbles: true,
            });

            mockContainer.dispatchEvent(mouseEvent);

            const target = inputManager.getPaddleTarget();
            expect(target).toEqual({ x: 400, y: 350 });
        });

        it('should update paddle target on mouse move', () => {
            // First position
            mockContainer.dispatchEvent(new MouseEvent('mousemove', {
                clientX: 200,
                clientY: 300,
                bubbles: true,
            }));
            expect(inputManager.getPaddleTarget()).toEqual({ x: 200, y: 300 });

            // Second position
            mockContainer.dispatchEvent(new MouseEvent('mousemove', {
                clientX: 600,
                clientY: 400,
                bubbles: true,
            }));
            expect(inputManager.getPaddleTarget()).toEqual({ x: 600, y: 400 });
        });

        it('should track mouse as active input type', () => {
            mockContainer.dispatchEvent(new MouseEvent('mousemove', {
                clientX: 400,
                clientY: 350,
                bubbles: true,
            }));

            const debugState = inputManager.getDebugState();
            expect(debugState.activeInputs).toContain('mouse');
        });
    });

    describe('Touch Input', () => {
        it('should normalize touch position to paddle target', () => {
            const touchEvent = new TouchEvent('touchmove', {
                touches: [
                    new Touch({
                        identifier: 1,
                        target: mockContainer,
                        clientX: 450,
                        clientY: 375,
                    }),
                ],
                bubbles: true,
            });

            mockContainer.dispatchEvent(touchEvent);

            const target = inputManager.getPaddleTarget();
            expect(target).toEqual({ x: 450, y: 375 });
        });

        it('should handle multiple touch points (use first touch)', () => {
            const touchEvent = new TouchEvent('touchmove', {
                touches: [
                    new Touch({
                        identifier: 1,
                        target: mockContainer,
                        clientX: 300,
                        clientY: 320,
                    }),
                    new Touch({
                        identifier: 2,
                        target: mockContainer,
                        clientX: 500,
                        clientY: 380,
                    }),
                ],
                bubbles: true,
            });

            mockContainer.dispatchEvent(touchEvent);

            const target = inputManager.getPaddleTarget();
            expect(target).toEqual({ x: 300, y: 320 }); // First touch
        });

        it('should track touch as active input type', () => {
            const touchEvent = new TouchEvent('touchmove', {
                touches: [
                    new Touch({
                        identifier: 1,
                        target: mockContainer,
                        clientX: 400,
                        clientY: 350,
                    }),
                ],
                bubbles: true,
            });

            mockContainer.dispatchEvent(touchEvent);

            const debugState = inputManager.getDebugState();
            expect(debugState.activeInputs).toContain('touch');
        });
    });

    describe('Keyboard Input', () => {
        it('should track keyboard state for arrow keys', () => {
            // Press left arrow
            document.dispatchEvent(new KeyboardEvent('keydown', { code: 'ArrowLeft' }));

            let debugState = inputManager.getDebugState();
            expect(debugState.keyboardPressed).toContain('ArrowLeft');

            // Press right arrow
            document.dispatchEvent(new KeyboardEvent('keydown', { code: 'ArrowRight' }));

            debugState = inputManager.getDebugState();
            expect(debugState.keyboardPressed).toContain('ArrowLeft');
            expect(debugState.keyboardPressed).toContain('ArrowRight');

            // Release left arrow
            document.dispatchEvent(new KeyboardEvent('keyup', { code: 'ArrowLeft' }));

            debugState = inputManager.getDebugState();
            expect(debugState.keyboardPressed).not.toContain('ArrowLeft');
            expect(debugState.keyboardPressed).toContain('ArrowRight');
        });

        it('should track keyboard state for WASD keys', () => {
            // Press 'A' key
            document.dispatchEvent(new KeyboardEvent('keydown', { code: 'KeyA' }));

            const debugState = inputManager.getDebugState();
            expect(debugState.keyboardPressed).toContain('KeyA');
        });

        it('should track keyboard as active input type', () => {
            document.dispatchEvent(new KeyboardEvent('keydown', { code: 'ArrowLeft' }));

            const debugState = inputManager.getDebugState();
            expect(debugState.activeInputs).toContain('keyboard');
        });
    });

    describe('Input Priority', () => {
        it('should prioritize mouse over touch', () => {
            // Touch first
            mockContainer.dispatchEvent(new TouchEvent('touchmove', {
                touches: [new Touch({ identifier: 1, target: mockContainer, clientX: 300, clientY: 320 })],
                bubbles: true,
            }));

            // Mouse second
            mockContainer.dispatchEvent(new MouseEvent('mousemove', {
                clientX: 500,
                clientY: 400,
                bubbles: true,
            }));

            const target = inputManager.getPaddleTarget();
            expect(target).toEqual({ x: 500, y: 400 }); // Mouse takes priority
        });

        it('should return null when no input is active', () => {
            const target = inputManager.getPaddleTarget();
            expect(target).toBeNull();
        });
    });

    describe('Input State Debug', () => {
        it('should provide comprehensive debug information', () => {
            // Simulate various inputs
            mockContainer.dispatchEvent(new MouseEvent('mousemove', {
                clientX: 400,
                clientY: 350,
                bubbles: true,
            }));
            document.dispatchEvent(new KeyboardEvent('keydown', { code: 'ArrowLeft' }));

            const debugState = inputManager.getDebugState();

            expect(debugState).toHaveProperty('activeInputs');
            expect(debugState).toHaveProperty('mousePosition');
            expect(debugState).toHaveProperty('keyboardPressed');
            expect(debugState).toHaveProperty('paddleTarget');
            expect(debugState).toHaveProperty('launchPending');

            expect(debugState.activeInputs).toContain('mouse');
            expect(debugState.activeInputs).toContain('keyboard');
            expect(debugState.mousePosition).toEqual({ x: 400, y: 350 });
            expect(debugState.keyboardPressed).toContain('ArrowLeft');
            expect(debugState.paddleTarget).toEqual({ x: 400, y: 350 });
        });
    });
});
</file>

<file path="tests/unit/input/launch-detection.spec.ts">
/**
 * Launch Trigger Detection Test Suite
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Test launch trigger detection from input events
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { GameInputManager } from 'input/input-manager';
import type { Vector2 } from 'input/contracts';

describe('Launch Trigger Detection', () => {
    let inputManager: GameInputManager;
    let mockContainer: HTMLElement;

    beforeEach(() => {
        mockContainer = document.createElement('div');
        document.body.appendChild(mockContainer);

        inputManager = new GameInputManager();
        inputManager.initialize(mockContainer);
    });

    afterEach(() => {
        document.body.removeChild(mockContainer);
    });

    describe('Movement-Based Launch Trigger', () => {
        it('should detect launch when paddle moves beyond threshold', () => {
            // This test would require mocking the internal launch manager
            // For now, test that the input manager has the expected interface
            expect(typeof inputManager.getPaddleTarget).toBe('function');
            expect(typeof inputManager.shouldLaunch).toBe('function');
            expect(typeof inputManager.resetLaunchTrigger).toBe('function');
        });

        it('should not trigger launch for small movements', () => {
            // Movement detection is internal - test that no launch is triggered initially
            expect(inputManager.shouldLaunch()).toBe(false);
        });

        it('should reset launch trigger after processing', () => {
            // Simulate launch trigger (this would be internal)
            // For testing, just verify the reset functionality
            inputManager.resetLaunchTrigger();
            expect(inputManager.shouldLaunch()).toBe(false);
        });
    });

    describe('Tap/Click Launch Trigger', () => {
        it('should detect launch on screen tap', () => {
            const tapEvent = new MouseEvent('mousedown', {
                clientX: 400,
                clientY: 350,
                bubbles: true,
            });

            mockContainer.dispatchEvent(tapEvent);

            // Should trigger launch
            expect(inputManager.shouldLaunch()).toBe(true);
        });

        it('should detect launch on touch tap', () => {
            const touchEvent = new TouchEvent('touchstart', {
                touches: [
                    new Touch({
                        identifier: 1,
                        target: mockContainer,
                        clientX: 400,
                        clientY: 350,
                    }),
                ],
                bubbles: true,
            });

            mockContainer.dispatchEvent(touchEvent);

            // Should trigger launch
            expect(inputManager.shouldLaunch()).toBe(true);
        });

        it('should handle multiple rapid taps', () => {
            // First tap
            const tap1 = new MouseEvent('mousedown', { clientX: 400, clientY: 350 });
            mockContainer.dispatchEvent(tap1);
            expect(inputManager.shouldLaunch()).toBe(true);

            // Reset
            inputManager.resetLaunchTrigger();
            expect(inputManager.shouldLaunch()).toBe(false);

            // Second tap
            const tap2 = new MouseEvent('mousedown', { clientX: 450, clientY: 350 });
            mockContainer.dispatchEvent(tap2);
            expect(inputManager.shouldLaunch()).toBe(true);
        });
    });

    describe('Launch State Management', () => {
        it('should maintain launch pending state', () => {
            // Initially no launch pending
            expect(inputManager.shouldLaunch()).toBe(false);

            // Set initial position
            inputManager.checkMovementLaunch({ x: 400, y: 350 });

            // Move paddle significantly to trigger launch
            inputManager.checkMovementLaunch({ x: 400, y: 250 }); // Move up 100 units

            // Should be pending
            expect(inputManager.shouldLaunch()).toBe(true);
        });

        it('should clear launch state after reset', () => {
            // Set launch pending
            expect(inputManager.shouldLaunch()).toBe(false);

            // Reset
            inputManager.resetLaunchTrigger();

            // Should be cleared
            expect(inputManager.shouldLaunch()).toBe(false);
        });

        it('should provide debug information about launch state', () => {
            const debugState = inputManager.getDebugState();

            expect(debugState).toHaveProperty('launchPending');
            expect(typeof debugState.launchPending).toBe('boolean');
        });
    });

    describe('Input Type Detection', () => {
        it('should identify mouse input for launch', () => {
            const mouseEvent = new MouseEvent('mousedown', { clientX: 400, clientY: 350 });
            mockContainer.dispatchEvent(mouseEvent);

            const debugState = inputManager.getDebugState();
            expect(debugState.activeInputs).toContain('mouse');
        });

        it('should identify touch input for launch', () => {
            const touchEvent = new TouchEvent('touchstart', {
                touches: [new Touch({ identifier: 1, target: mockContainer, clientX: 400, clientY: 350 })],
            });
            mockContainer.dispatchEvent(touchEvent);

            const debugState = inputManager.getDebugState();
            expect(debugState.activeInputs).toContain('touch');
        });
    });
});
</file>

<file path="tests/unit/physics/ball-attachment.spec.ts">
/**
 * Ball Attachment Mechanics Test Suite
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Test ball attachment state and mechanics
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { Bodies, Engine, World } from 'matter-js';
import type { BallController, Ball, BallOptions, Vector2 } from 'physics/contracts';
import { createPhysicsWorld } from 'physics/world';

describe('Ball Attachment Mechanics', () => {
    let world: ReturnType<typeof createPhysicsWorld>;
    let ballController: BallController;
    let mockBall: Ball;

    beforeEach(() => {
        world = createPhysicsWorld();
        mockBall = {
            id: 'test-ball',
            physicsBody: world.factory.ball({ radius: 8, position: { x: 400, y: 300 } }),
            isAttached: false,
            attachmentOffset: { x: 0, y: -10 },
            radius: 8,
        };

        // Add mock ball to world
        world.add(mockBall.physicsBody);
    });

    describe('Ball Attachment State', () => {
        it('should create ball in detached state by default', () => {
            const paddlePosition: Vector2 = { x: 400, y: 350 };
            const options: BallOptions = { radius: 8 };

            // Create attached ball
            const ball = world.factory.ball({
                position: { x: paddlePosition.x, y: paddlePosition.y - 10 },
                radius: options.radius || 8,
                label: 'test-ball',
            });

            expect(ball.position.x).toBeCloseTo(paddlePosition.x, 0);
            expect(ball.position.y).toBeCloseTo(paddlePosition.y - 10, 0);
            expect(ball.circleRadius).toBe(8);
        });

        it('should track attachment state correctly', () => {
            const paddlePosition: Vector2 = { x: 400, y: 350 };

            // Initially not attached
            expect(world.isBallAttached(mockBall.physicsBody)).toBe(false);

            // Attach ball
            world.attachBallToPaddle(mockBall.physicsBody, world.factory.paddle({
                position: paddlePosition,
                size: { width: 100, height: 20 },
            }));

            expect(world.isBallAttached(mockBall.physicsBody)).toBe(true);

            // Detach ball
            world.detachBallFromPaddle(mockBall.physicsBody);
            expect(world.isBallAttached(mockBall.physicsBody)).toBe(false);
        });

        it('should maintain attachment offset', () => {
            const paddlePosition: Vector2 = { x: 400, y: 350 };
            const offset: Vector2 = { x: 0, y: -15 };

            const paddle = world.factory.paddle({
                position: paddlePosition,
                size: { width: 100, height: 20 },
            });

            world.attachBallToPaddle(mockBall.physicsBody, paddle, offset);

            // Update attachment (simulate paddle movement)
            const newPaddlePosition: Vector2 = { x: 420, y: 350 };
            world.updateBallAttachment(mockBall.physicsBody, newPaddlePosition);

            expect(mockBall.physicsBody.position.x).toBeCloseTo(newPaddlePosition.x + offset.x, 0);
            expect(mockBall.physicsBody.position.y).toBeCloseTo(newPaddlePosition.y + offset.y, 0);
        });

        it('should prevent ball movement when attached', () => {
            const paddlePosition: Vector2 = { x: 400, y: 350 };
            const paddle = world.factory.paddle({
                position: paddlePosition,
                size: { width: 100, height: 20 },
            });

            world.attachBallToPaddle(mockBall.physicsBody, paddle);

            // Apply force to ball (should be ignored when attached)
            mockBall.physicsBody.force.x = 10;
            mockBall.physicsBody.force.y = 5;

            // Step physics
            world.step(1000 / 60);

            // Ball should still be at attachment position
            const attachment = world.getBallAttachment(mockBall.physicsBody);
            expect(attachment).toBeDefined();
            expect(attachment!.isAttached).toBe(true);

            // Position should be synced to paddle
            expect(mockBall.physicsBody.position.x).toBeCloseTo(paddlePosition.x + attachment!.attachmentOffset.x, 0);
            expect(mockBall.physicsBody.position.y).toBeCloseTo(paddlePosition.y + attachment!.attachmentOffset.y, 0);
        });

        it('should allow ball movement when detached', () => {
            // Create a fresh ball for this test
            const testBall = world.factory.ball({ radius: 8, position: { x: 400, y: 300 } });
            world.add(testBall);

            const initialPosition = { ...testBall.position };

            // Apply velocity
            testBall.velocity.x = 50;
            testBall.velocity.y = -30;

            // Step physics
            world.step(1000 / 60);

            // Ball should have moved
            const deltaX = Math.abs(testBall.position.x - initialPosition.x);
            const deltaY = Math.abs(testBall.position.y - initialPosition.y);
            expect(deltaX + deltaY).toBeGreaterThan(0.1); // Should have moved at least a tiny bit
        });

        it('should handle attachment to moving paddle', () => {
            const initialPaddlePosition: Vector2 = { x: 400, y: 350 };
            const paddle = world.factory.paddle({
                position: initialPaddlePosition,
                size: { width: 100, height: 20 },
            });

            world.attachBallToPaddle(mockBall.physicsBody, paddle);

            // Move paddle
            const newPaddlePosition: Vector2 = { x: 450, y: 360 };
            world.updateBallAttachment(mockBall.physicsBody, newPaddlePosition);

            // Ball should follow paddle
            const attachment = world.getBallAttachment(mockBall.physicsBody);
            expect(mockBall.physicsBody.position.x).toBeCloseTo(newPaddlePosition.x + attachment!.attachmentOffset.x, 0);
            expect(mockBall.physicsBody.position.y).toBeCloseTo(newPaddlePosition.y + attachment!.attachmentOffset.y, 0);
        });

        it('should reset ball to attached state', () => {
            const paddlePosition: Vector2 = { x: 400, y: 350 };
            const paddle = world.factory.paddle({
                position: paddlePosition,
                size: { width: 100, height: 20 },
            });

            // Ball starts detached
            world.detachBallFromPaddle(mockBall.physicsBody);

            // Move ball away
            mockBall.physicsBody.position.x = 200;
            mockBall.physicsBody.position.y = 200;

            // Reset to attached
            world.attachBallToPaddle(mockBall.physicsBody, paddle);

            // Ball should be at attachment position
            const attachment = world.getBallAttachment(mockBall.physicsBody);
            expect(attachment!.isAttached).toBe(true);
            expect(mockBall.physicsBody.position.x).toBeCloseTo(paddlePosition.x + attachment!.attachmentOffset.x, 0);
            expect(mockBall.physicsBody.position.y).toBeCloseTo(paddlePosition.y + attachment!.attachmentOffset.y, 0);
        });
    });

    describe('Attachment Edge Cases', () => {
        it('should handle zero offset attachment', () => {
            const paddlePosition: Vector2 = { x: 400, y: 350 };
            const paddle = world.factory.paddle({
                position: paddlePosition,
                size: { width: 100, height: 20 },
            });

            world.attachBallToPaddle(mockBall.physicsBody, paddle, { x: 0, y: 0 });

            const attachment = world.getBallAttachment(mockBall.physicsBody);
            expect(attachment!.attachmentOffset).toEqual({ x: 0, y: 0 });
            expect(mockBall.physicsBody.position.x).toBeCloseTo(paddlePosition.x, 0);
            expect(mockBall.physicsBody.position.y).toBeCloseTo(paddlePosition.y, 0);
        });

        it('should handle multiple attachment/detachment cycles', () => {
            const paddlePosition: Vector2 = { x: 400, y: 350 };
            const paddle = world.factory.paddle({
                position: paddlePosition,
                size: { width: 100, height: 20 },
            });

            // Cycle through attach/detach multiple times
            for (let i = 0; i < 3; i++) {
                world.attachBallToPaddle(mockBall.physicsBody, paddle);
                expect(world.isBallAttached(mockBall.physicsBody)).toBe(true);

                world.detachBallFromPaddle(mockBall.physicsBody);
                expect(world.isBallAttached(mockBall.physicsBody)).toBe(false);
            }
        });

        it('should return null for unattached balls', () => {
            world.detachBallFromPaddle(mockBall.physicsBody);
            const attachment = world.getBallAttachment(mockBall.physicsBody);
            expect(attachment).toBeNull();
        });
    });
});
</file>

<file path="tests/unit/physics/contracts.spec.ts">
/**
 * Physics Contracts Test Suite
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Test the physics contracts and interfaces
 */

import { describe, it, expect } from 'vitest';
import type { BallController, Ball, BallOptions, BallDebugInfo, Vector2 } from 'physics/contracts';

describe('Physics Contracts', () => {
    describe('BallController Interface', () => {
        it('should define required methods', () => {
            // Type-only test - ensures interface compiles correctly
            const ballController: BallController = {
                createAttachedBall: () => ({} as Ball),
                updateAttachment: () => { },
                launchBall: () => { },
                isAttached: () => false,
                resetToAttached: () => { },
                getDebugInfo: () => ({} as BallDebugInfo),
            };

            expect(ballController).toBeDefined();
            expect(typeof ballController.createAttachedBall).toBe('function');
            expect(typeof ballController.updateAttachment).toBe('function');
            expect(typeof ballController.launchBall).toBe('function');
            expect(typeof ballController.isAttached).toBe('function');
            expect(typeof ballController.resetToAttached).toBe('function');
            expect(typeof ballController.getDebugInfo).toBe('function');
        });
    });

    describe('Ball Interface', () => {
        it('should define ball properties', () => {
            const ball: Ball = {
                id: 'ball-1',
                physicsBody: { id: 123 }, // Mock Matter.js body
                isAttached: true,
                attachmentOffset: { x: 0, y: -10 },
                radius: 8,
            };

            expect(ball.id).toBe('ball-1');
            expect(ball.physicsBody).toBeDefined();
            expect(ball.isAttached).toBe(true);
            expect(ball.attachmentOffset).toEqual({ x: 0, y: -10 });
            expect(ball.radius).toBe(8);
        });
    });

    describe('BallOptions Interface', () => {
        it('should define optional ball configuration', () => {
            const options: BallOptions = {
                radius: 10,
                restitution: 0.8,
                friction: 0.1,
            };

            expect(options.radius).toBe(10);
            expect(options.restitution).toBe(0.8);
            expect(options.friction).toBe(0.1);
        });

        it('should allow partial configuration', () => {
            const options: BallOptions = {
                radius: 12,
            };

            expect(options.radius).toBe(12);
            expect(options.restitution).toBeUndefined();
            expect(options.friction).toBeUndefined();
        });
    });

    describe('BallDebugInfo Interface', () => {
        it('should define debug information structure', () => {
            const debugInfo: BallDebugInfo = {
                position: { x: 100, y: 200 },
                velocity: { x: 5, y: -3 },
                isAttached: false,
                attachmentOffset: { x: 0, y: 0 },
                physicsBodyId: 456,
            };

            expect(debugInfo.position).toEqual({ x: 100, y: 200 });
            expect(debugInfo.velocity).toEqual({ x: 5, y: -3 });
            expect(debugInfo.isAttached).toBe(false);
            expect(debugInfo.attachmentOffset).toEqual({ x: 0, y: 0 });
            expect(debugInfo.physicsBodyId).toBe(456);
        });
    });

    describe('Vector2 Interface', () => {
        it('should define 2D vector properties', () => {
            const vector: Vector2 = { x: 15, y: 25 };
            expect(vector.x).toBe(15);
            expect(vector.y).toBe(25);
        });
    });
});
</file>

<file path="tests/unit/render/contracts.spec.ts">
/**
 * Render Contracts Test Suite
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Test the render contracts and interfaces
 */

import { describe, it, expect } from 'vitest';
import type {
    PaddleController,
    Paddle,
    PaddleOptions,
    InputState,
    Rectangle,
    BoundaryCollision,
    PaddleDebugInfo,
    Vector2
} from 'render/contracts';

describe('Render Contracts', () => {
    describe('PaddleController Interface', () => {
        it('should define required methods', () => {
            // Type-only test - ensures interface compiles correctly
            const paddleController: PaddleController = {
                createPaddle: () => ({} as Paddle),
                updatePaddle: () => { },
                setPaddlePosition: () => { },
                getPaddleBounds: () => ({} as Rectangle),
                getPaddleCenter: () => ({} as Vector2),
                checkBoundaryCollision: () => ({} as BoundaryCollision),
                getDebugInfo: () => ({} as PaddleDebugInfo),
            };

            expect(paddleController).toBeDefined();
            expect(typeof paddleController.createPaddle).toBe('function');
            expect(typeof paddleController.updatePaddle).toBe('function');
            expect(typeof paddleController.setPaddlePosition).toBe('function');
            expect(typeof paddleController.getPaddleBounds).toBe('function');
            expect(typeof paddleController.getPaddleCenter).toBe('function');
            expect(typeof paddleController.checkBoundaryCollision).toBe('function');
            expect(typeof paddleController.getDebugInfo).toBe('function');
        });
    });

    describe('Paddle Interface', () => {
        it('should define paddle properties', () => {
            const paddle: Paddle = {
                id: 'paddle-1',
                physicsBody: { id: 789 }, // Mock Matter.js body
                width: 80,
                height: 12,
                speed: 300,
                position: { x: 200, y: 450 },
            };

            expect(paddle.id).toBe('paddle-1');
            expect(paddle.physicsBody).toBeDefined();
            expect(paddle.width).toBe(80);
            expect(paddle.height).toBe(12);
            expect(paddle.speed).toBe(300);
            expect(paddle.position).toEqual({ x: 200, y: 450 });
        });
    });

    describe('PaddleOptions Interface', () => {
        it('should define optional paddle configuration', () => {
            const options: PaddleOptions = {
                width: 100,
                height: 15,
                speed: 400,
                color: 0xff0000,
            };

            expect(options.width).toBe(100);
            expect(options.height).toBe(15);
            expect(options.speed).toBe(400);
            expect(options.color).toBe(0xff0000);
        });

        it('should allow partial configuration', () => {
            const options: PaddleOptions = {
                width: 120,
            };

            expect(options.width).toBe(120);
            expect(options.height).toBeUndefined();
            expect(options.speed).toBeUndefined();
            expect(options.color).toBeUndefined();
        });
    });

    describe('InputState Interface', () => {
        it('should define input state properties', () => {
            const inputState: InputState = {
                leftPressed: true,
                rightPressed: false,
                mouseX: 250,
                touchX: undefined,
                launchRequested: true,
            };

            expect(inputState.leftPressed).toBe(true);
            expect(inputState.rightPressed).toBe(false);
            expect(inputState.mouseX).toBe(250);
            expect(inputState.touchX).toBeUndefined();
            expect(inputState.launchRequested).toBe(true);
        });

        it('should handle touch input', () => {
            const inputState: InputState = {
                leftPressed: false,
                rightPressed: false,
                mouseX: undefined,
                touchX: 300,
                launchRequested: false,
            };

            expect(inputState.leftPressed).toBe(false);
            expect(inputState.rightPressed).toBe(false);
            expect(inputState.mouseX).toBeUndefined();
            expect(inputState.touchX).toBe(300);
            expect(inputState.launchRequested).toBe(false);
        });
    });

    describe('Rectangle Interface', () => {
        it('should define rectangle properties', () => {
            const rect: Rectangle = {
                x: 100,
                y: 200,
                width: 80,
                height: 12,
            };

            expect(rect.x).toBe(100);
            expect(rect.y).toBe(200);
            expect(rect.width).toBe(80);
            expect(rect.height).toBe(12);
        });
    });

    describe('BoundaryCollision Interface', () => {
        it('should define boundary collision flags', () => {
            const collision: BoundaryCollision = {
                left: false,
                right: true,
            };

            expect(collision.left).toBe(false);
            expect(collision.right).toBe(true);
        });
    });

    describe('PaddleDebugInfo Interface', () => {
        it('should define debug information structure', () => {
            const debugInfo: PaddleDebugInfo = {
                position: { x: 200, y: 450 },
                velocity: { x: 0, y: 0 },
                bounds: { x: 160, y: 444, width: 80, height: 12 },
                physicsBodyId: 789,
                inputState: {
                    leftPressed: false,
                    rightPressed: false,
                    mouseX: 200,
                    touchX: undefined,
                    launchRequested: false,
                },
            };

            expect(debugInfo.position).toEqual({ x: 200, y: 450 });
            expect(debugInfo.velocity).toEqual({ x: 0, y: 0 });
            expect(debugInfo.bounds).toEqual({ x: 160, y: 444, width: 80, height: 12 });
            expect(debugInfo.physicsBodyId).toBe(789);
            expect(debugInfo.inputState.leftPressed).toBe(false);
        });
    });

    describe('Vector2 Interface', () => {
        it('should define 2D vector properties', () => {
            const vector: Vector2 = { x: 50, y: 75 };
            expect(vector.x).toBe(50);
            expect(vector.y).toBe(75);
        });
    });
});
</file>

<file path="tests/unit/render/paddle-constraints.spec.ts">
/**
 * Paddle Boundary Constraints Test Suite
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Test paddle boundary constraints and collision detection
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { PaddleBodyController } from 'render/paddle-body';
import type { Vector2, Rectangle } from 'render/contracts';

describe('Paddle Boundary Constraints', () => {
    let paddleController: PaddleBodyController;
    let mockPaddle: any;

    beforeEach(() => {
        paddleController = new PaddleBodyController();
        mockPaddle = {
            id: 'test-paddle',
            physicsBody: {
                position: { x: 400, y: 350 },
                isStatic: true,
            },
            width: 100,
            height: 20,
            speed: 300,
            position: { x: 400, y: 350 },
        };
    });

    describe('Paddle Bounds Calculation', () => {
        it('should calculate paddle bounds correctly', () => {
            const bounds = paddleController.getPaddleBounds(mockPaddle);

            expect(bounds.x).toBe(350); // center - half width
            expect(bounds.y).toBe(340); // center - half height
            expect(bounds.width).toBe(100);
            expect(bounds.height).toBe(20);
        });

        it('should calculate paddle center correctly', () => {
            const center = paddleController.getPaddleCenter(mockPaddle);
            expect(center).toEqual({ x: 400, y: 350 });
        });

        it('should handle different paddle sizes', () => {
            const largePaddle = { ...mockPaddle, width: 150, height: 30 };
            const bounds = paddleController.getPaddleBounds(largePaddle);

            expect(bounds.x).toBe(325); // 400 - 75
            expect(bounds.y).toBe(335); // 350 - 15
            expect(bounds.width).toBe(150);
            expect(bounds.height).toBe(30);
        });
    });

    describe('Boundary Collision Detection', () => {
        it('should detect left boundary collision', () => {
            // Paddle at left edge
            mockPaddle.position.x = 50; // Half width (50) touches left boundary
            const collision = paddleController.checkBoundaryCollision(mockPaddle, 800);

            expect(collision.left).toBe(true);
            expect(collision.right).toBe(false);
        });

        it('should detect right boundary collision', () => {
            // Paddle at right edge
            mockPaddle.position.x = 750; // 800 - half width (50)
            const collision = paddleController.checkBoundaryCollision(mockPaddle, 800);

            expect(collision.left).toBe(false);
            expect(collision.right).toBe(true);
        });

        it('should detect no collision when paddle is centered', () => {
            mockPaddle.position.x = 400;
            const collision = paddleController.checkBoundaryCollision(mockPaddle, 800);

            expect(collision.left).toBe(false);
            expect(collision.right).toBe(false);
        });

        it('should handle different screen widths', () => {
            // Narrow screen
            mockPaddle.position.x = 475; // 500 - 25 (half width)
            const collision = paddleController.checkBoundaryCollision(mockPaddle, 500);

            expect(collision.right).toBe(true);
        });
    });

    describe('Position Constraints', () => {
        it('should constrain paddle within left boundary', () => {
            const outOfBoundsPosition: Vector2 = { x: 20, y: 350 }; // Too far left
            paddleController.setPaddlePosition(mockPaddle, outOfBoundsPosition);

            expect(mockPaddle.position.x).toBe(50); // Constrained to half width
            expect(mockPaddle.position.y).toBe(350);
        });

        it('should constrain paddle within right boundary', () => {
            const outOfBoundsPosition: Vector2 = { x: 1300, y: 350 }; // Too far right
            paddleController.setPaddlePosition(mockPaddle, outOfBoundsPosition);

            expect(mockPaddle.position.x).toBe(1230); // Constrained to 1280 - 50 (half width)
            expect(mockPaddle.position.y).toBe(350);
        });

        it('should allow valid positions', () => {
            const validPosition: Vector2 = { x: 400, y: 350 };
            paddleController.setPaddlePosition(mockPaddle, validPosition);

            expect(mockPaddle.position.x).toBe(400);
            expect(mockPaddle.position.y).toBe(350);
        });

        it('should constrain to boundaries during updates', () => {
            // Simulate update that would go out of bounds
            const inputState = {
                leftPressed: false,
                rightPressed: false,
                mouseX: 20, // Out of bounds
                touchX: undefined,
                launchRequested: false,
            };

            paddleController.updatePaddle(mockPaddle, 1 / 60, inputState);

            expect(mockPaddle.position.x).toBe(50); // Constrained
        });
    });

    describe('Movement Updates', () => {
        it('should update paddle position based on mouse input', () => {
            const inputState = {
                leftPressed: false,
                rightPressed: false,
                mouseX: 500,
                touchX: undefined,
                launchRequested: false,
            };

            paddleController.updatePaddle(mockPaddle, 1 / 60, inputState);

            expect(mockPaddle.position.x).toBe(500);
        });

        it('should prioritize mouse over touch input', () => {
            const inputState = {
                leftPressed: false,
                rightPressed: false,
                mouseX: 300,
                touchX: 600, // Should be ignored
                launchRequested: false,
            };

            paddleController.updatePaddle(mockPaddle, 1 / 60, inputState);

            expect(mockPaddle.position.x).toBe(300);
        });

        it('should handle keyboard input simulation', () => {
            // Note: Keyboard input is handled differently in the actual implementation
            // This test verifies the interface
            expect(typeof paddleController.updatePaddle).toBe('function');
        });

        it('should maintain vertical position stability', () => {
            const initialY = mockPaddle.position.y;

            const inputState = {
                leftPressed: false,
                rightPressed: false,
                mouseX: 500,
                touchX: undefined,
                launchRequested: false,
            };

            paddleController.updatePaddle(mockPaddle, 1 / 60, inputState);

            expect(mockPaddle.position.y).toBe(initialY);
        });
    });

    describe('Physics Body Synchronization', () => {
        it('should sync physics body with paddle position', () => {
            const newPosition: Vector2 = { x: 450, y: 355 };
            paddleController.setPaddlePosition(mockPaddle, newPosition);

            expect(mockPaddle.physicsBody.position.x).toBe(450);
            expect(mockPaddle.physicsBody.position.y).toBe(355);
        });

        it('should maintain physics body static property', () => {
            expect(mockPaddle.physicsBody.isStatic).toBe(true);
        });
    });

    describe('Edge Cases', () => {
        it('should handle zero-sized paddle', () => {
            const zeroPaddle = { ...mockPaddle, width: 0, height: 0 };
            const bounds = paddleController.getPaddleBounds(zeroPaddle);

            expect(bounds.x).toBe(400);
            expect(bounds.y).toBe(350);
            expect(bounds.width).toBe(0);
            expect(bounds.height).toBe(0);
        });

        it('should handle negative positions', () => {
            const negativePosition: Vector2 = { x: -100, y: -50 };
            paddleController.setPaddlePosition(mockPaddle, negativePosition);

            expect(mockPaddle.position.x).toBe(50); // Constrained
            expect(mockPaddle.position.y).toBe(-50); // Y not constrained in this implementation
        });

        it('should handle very large screen widths', () => {
            const largeScreenPosition: Vector2 = { x: 2000, y: 350 };
            paddleController.setPaddlePosition(mockPaddle, largeScreenPosition);

            expect(mockPaddle.position.x).toBe(1230); // Constrained to 1280 - 50
        });
    });
});
</file>

<file path="tests/unit/render/paddle-positioning.spec.ts">
/**
 * Paddle Positioning Test Suite
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Test paddle positioning and kinematic body behavior
 */

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { Bodies } from 'matter-js';
import type { PaddleController, Paddle, PaddleOptions, Vector2, Rectangle } from 'render/contracts';
import { createPhysicsWorld } from 'physics/world';

describe('Paddle Positioning', () => {
    let world: ReturnType<typeof createPhysicsWorld>;
    let mockPaddle: Paddle;

    beforeEach(() => {
        world = createPhysicsWorld();
        mockPaddle = {
            id: 'test-paddle',
            physicsBody: Bodies.rectangle(400, 350, 100, 20, { isStatic: true }),
            width: 100,
            height: 20,
            speed: 300,
            position: { x: 400, y: 350 },
        };

        // Add mock paddle to world
        world.add(mockPaddle.physicsBody);
    });

    afterEach(() => {
        world.dispose();
    });

    describe('Paddle Creation', () => {
        it('should create paddle with correct initial position', () => {
            const initialPos = { x: 400, y: 350 };
            const paddle = {
                id: 'test-paddle',
                physicsBody: Bodies.rectangle(initialPos.x, initialPos.y, 100, 20, { isStatic: true }),
                width: 100,
                height: 20,
                speed: 300,
                position: initialPos,
            };

            expect(paddle.position.x).toBe(400);
            expect(paddle.position.y).toBe(350);
            expect(paddle.width).toBe(100);
            expect(paddle.height).toBe(20);
            expect(paddle.speed).toBe(300);
        });

        it('should create paddle with custom options', () => {
            const options = { width: 120, height: 25, speed: 400 };
            const paddle = {
                id: 'custom-paddle',
                physicsBody: Bodies.rectangle(400, 350, options.width, options.height, { isStatic: true }),
                width: options.width,
                height: options.height,
                speed: options.speed,
                position: { x: 400, y: 350 },
            };

            expect(paddle.width).toBe(120);
            expect(paddle.height).toBe(25);
            expect(paddle.speed).toBe(400);
        });
    });

    describe('Position Updates', () => {
        it('should update paddle position from physics body', () => {
            // Simulate physics body position change
            mockPaddle.physicsBody.position.x = 450;
            mockPaddle.physicsBody.position.y = 360;

            // Update paddle position to match physics
            mockPaddle.position.x = mockPaddle.physicsBody.position.x;
            mockPaddle.position.y = mockPaddle.physicsBody.position.y;

            expect(mockPaddle.position.x).toBe(450);
            expect(mockPaddle.position.y).toBe(360);
        });

        it('should maintain paddle dimensions during position updates', () => {
            const originalWidth = mockPaddle.width;
            const originalHeight = mockPaddle.height;

            // Update position
            mockPaddle.position.x = 500;
            mockPaddle.position.y = 370;

            expect(mockPaddle.width).toBe(originalWidth);
            expect(mockPaddle.height).toBe(originalHeight);
        });
    });

    describe('Boundary Constraints', () => {
        it('should constrain paddle within screen bounds', () => {
            const screenWidth = 800;
            const paddleHalfWidth = mockPaddle.width / 2;

            // Test left boundary
            const leftPosition = { x: 10, y: 350 };
            const constrainedLeft = {
                x: Math.max(paddleHalfWidth, Math.min(screenWidth - paddleHalfWidth, leftPosition.x)),
                y: leftPosition.y,
            };

            expect(constrainedLeft.x).toBe(paddleHalfWidth);

            // Test right boundary
            const rightPosition = { x: 850, y: 350 };
            const constrainedRight = {
                x: Math.max(paddleHalfWidth, Math.min(screenWidth - paddleHalfWidth, rightPosition.x)),
                y: rightPosition.y,
            };

            expect(constrainedRight.x).toBe(screenWidth - paddleHalfWidth);

            // Test valid position
            const validPosition = { x: 400, y: 350 };
            const constrainedValid = {
                x: Math.max(paddleHalfWidth, Math.min(screenWidth - paddleHalfWidth, validPosition.x)),
                y: validPosition.y,
            };

            expect(constrainedValid.x).toBe(400);
        });

        it('should calculate paddle bounds correctly', () => {
            const paddleLeft = mockPaddle.position.x - mockPaddle.width / 2;
            const paddleTop = mockPaddle.position.y - mockPaddle.height / 2;
            const paddleRight = mockPaddle.position.x + mockPaddle.width / 2;
            const paddleBottom = mockPaddle.position.y + mockPaddle.height / 2;

            const centerX = paddleLeft + mockPaddle.width / 2;
            const centerY = paddleTop + mockPaddle.height / 2;

            expect(centerX).toBe(mockPaddle.position.x);
            expect(centerY).toBe(mockPaddle.position.y);
            expect(paddleRight - paddleLeft).toBe(mockPaddle.width);
            expect(paddleBottom - paddleTop).toBe(mockPaddle.height);
        });
    });

    describe('Physics Body Integration', () => {
        it('should maintain static body properties', () => {
            expect(mockPaddle.physicsBody.isStatic).toBe(true);
        });

        it('should sync physics body with paddle state', () => {
            const newPosition: Vector2 = { x: 380, y: 348 };

            mockPaddle.position = newPosition;
            mockPaddle.physicsBody.position.x = newPosition.x;
            mockPaddle.physicsBody.position.y = newPosition.y;

            expect(mockPaddle.physicsBody.position.x).toBe(mockPaddle.position.x);
            expect(mockPaddle.physicsBody.position.y).toBe(mockPaddle.position.y);
        });
    });

    describe('Movement Patterns', () => {
        it('should handle smooth horizontal movement', () => {
            const positions: Vector2[] = [
                { x: 350, y: 350 },
                { x: 375, y: 350 },
                { x: 400, y: 350 },
                { x: 425, y: 350 },
                { x: 450, y: 350 },
            ];

            positions.forEach((pos, index) => {
                mockPaddle.physicsBody.position.x = pos.x;
                mockPaddle.physicsBody.position.y = pos.y;
                mockPaddle.position = pos;

                expect(mockPaddle.position.x).toBe(pos.x);
                expect(mockPaddle.position.y).toBe(pos.y);

                if (index > 0) {
                    const distance = Math.abs(pos.x - positions[index - 1].x);
                    expect(distance).toBe(25); // Consistent movement
                }
            });
        });

        it('should handle rapid position changes', () => {
            const startPosition = { ...mockPaddle.position };
            const endPosition: Vector2 = { x: 600, y: 350 };

            mockPaddle.physicsBody.position.x = endPosition.x;
            mockPaddle.physicsBody.position.y = endPosition.y;
            mockPaddle.position = endPosition;

            expect(mockPaddle.position.x).toBe(endPosition.x);
            expect(mockPaddle.position.y).toBe(endPosition.y);
            expect(mockPaddle.position.x).not.toBe(startPosition.x);
        });

        it('should maintain vertical stability', () => {
            const initialY = mockPaddle.position.y;

            // Move horizontally multiple times
            const horizontalMoves = [300, 350, 400, 450, 500];
            horizontalMoves.forEach(x => {
                mockPaddle.physicsBody.position.x = x;
                mockPaddle.position.x = x;
                expect(mockPaddle.position.y).toBe(initialY);
            });
        });
    });
});
</file>

<file path="tests/unit/render/stage.spec.ts">
import { beforeEach, describe, expect, it, vi } from 'vitest';

vi.mock('pixi.js', async () => {
    class Container {
        public children: unknown[] = [];
        public sortableChildren = false;
        public name = '';
        public label = '';
        public parent: Container | null = null;

        addChild<T>(...items: T[]): T {
            this.children.push(...items);
            items.forEach((item) => {
                (item as { parent?: Container | null }).parent = this;
            });
            return items[0];
        }

        removeChild<T>(item: T): T {
            this.children = this.children.filter((child) => child !== item);
            (item as { parent?: Container | null }).parent = null;
            return item;
        }
    }

    class Sprite extends Container {
        public visible = true;
        public alpha = 1;
    }

    class Renderer {
        public width: number;
        public height: number;
        public background: { color: number };

        public constructor(width: number, height: number) {
            this.width = width;
            this.height = height;
            this.background = { color: 0 };
        }

        public resize(size: { width: number; height: number }): void {
            this.width = size.width;
            this.height = size.height;
        }
    }

    class Application {
        public readonly stage: Container;
        public readonly renderer: Renderer;
        public canvas: HTMLCanvasElement;
        public destroyed = false;

        public constructor() {
            this.stage = new Container();
            this.renderer = new Renderer(0, 0);
            this.canvas = ({ width: 0, height: 0 } as HTMLCanvasElement);
        }

        public async init(options: { width: number; height: number; canvas?: HTMLCanvasElement }): Promise<void> {
            this.renderer.width = options.width;
            this.renderer.height = options.height;
            this.canvas = options.canvas ?? ({ width: options.width, height: options.height } as HTMLCanvasElement);
        }

        public destroy(): void {
            this.destroyed = true;
        }
    }

    return {
        Application,
        Container,
        Sprite,
    };
});

import { createStage } from '@render/stage';

describe('createStage', () => {
    it('initialises the stage with layered containers', async () => {
        const stage = await createStage({ width: 1024, height: 768, background: 0x112233 });

        expect(stage.app.renderer.width).toBe(1024);
        expect(stage.app.renderer.height).toBe(768);
        expect(stage.layers.playfield.label).toBe('playfield');
        expect(stage.layers.hud.label).toBe('hud');
        expect(stage.layers.effects.label).toBe('effects');

        stage.destroy();
        expect((stage.app as { destroyed?: boolean }).destroyed).toBe(true);
    });

    it('provides sprite pooling and layer management helpers', async () => {
        const stage = await createStage({ width: 640, height: 360 });

        const sprite = stage.acquireSprite();
        stage.addToLayer('hud', sprite);

        expect(stage.layers.hud.children).toContain(sprite);

        stage.releaseSprite(sprite);
        expect(stage.layers.hud.children).not.toContain(sprite);

        stage.destroy();
    });

    it('resizes the renderer on demand', async () => {
        const stage = await createStage({ width: 400, height: 300 });

        stage.resize({ width: 800, height: 600 });

        expect(stage.app.renderer.width).toBe(800);
        expect(stage.app.renderer.height).toBe(600);

        stage.destroy();
    });
});
</file>

<file path="tests/unit/util/paddle-reflection.spec.ts">
/**
 * Tests for Paddle Reflection Utilities
 */

import { describe, it, expect } from 'vitest';
import { reflectOffPaddle, calculateReflectionData, getHitOffset } from 'util/paddle-reflection';
import { Bodies, Body } from 'matter-js';

describe('paddle-reflection', () => {
    describe('reflectOffPaddle', () => {
        it('should reflect ball upward from center hit', () => {
            const ball = Bodies.circle(100, 100, 10);
            const paddle = Bodies.rectangle(100, 150, 100, 20, { isStatic: true });
            Body.setVelocity(ball, { x: 0, y: 5 });

            reflectOffPaddle(ball, paddle, {
                paddleWidth: 100,
                minSpeed: 8,
            });

            expect(ball.velocity.x).toBeCloseTo(0, 1);
            expect(ball.velocity.y).toBeLessThan(0); // Upward
            expect(Math.sqrt(ball.velocity.x ** 2 + ball.velocity.y ** 2)).toBeCloseTo(8, 1);
        });

        it('should reflect ball at angle from edge hit', () => {
            const ball = Bodies.circle(140, 100, 10); // Right edge
            const paddle = Bodies.rectangle(100, 150, 100, 20, { isStatic: true });
            Body.setVelocity(ball, { x: 0, y: 5 });

            reflectOffPaddle(ball, paddle, {
                paddleWidth: 100,
                minSpeed: 8,
            });

            expect(ball.velocity.x).toBeGreaterThan(0); // Rightward angle
            expect(ball.velocity.y).toBeLessThan(0); // Upward
        });

        it('should enforce minimum speed', () => {
            const ball = Bodies.circle(100, 100, 10);
            const paddle = Bodies.rectangle(100, 150, 100, 20, { isStatic: true });
            Body.setVelocity(ball, { x: 0, y: 1 }); // Slow speed

            reflectOffPaddle(ball, paddle, {
                paddleWidth: 100,
                minSpeed: 8,
            });

            const speed = Math.sqrt(ball.velocity.x ** 2 + ball.velocity.y ** 2);
            expect(speed).toBeCloseTo(8, 1);
        });
    });

    describe('calculateReflectionData', () => {
        it('should return zero angle for center hit', () => {
            const data = calculateReflectionData(100, 100, { paddleWidth: 100, minSpeed: 8 });
            expect(data.angle).toBeCloseTo(0, 2);
            expect(data.impactOffset).toBeCloseTo(0, 2);
        });

        it('should return positive angle for right edge hit', () => {
            const data = calculateReflectionData(150, 100, { paddleWidth: 100, minSpeed: 8 });
            expect(data.angle).toBeGreaterThan(0);
            expect(data.impactOffset).toBeCloseTo(1, 1);
        });

        it('should return negative angle for left edge hit', () => {
            const data = calculateReflectionData(50, 100, { paddleWidth: 100, minSpeed: 8 });
            expect(data.angle).toBeLessThan(0);
            expect(data.impactOffset).toBeCloseTo(-1, 1);
        });
    });

    describe('getHitOffset', () => {
        it('should return 0 for center hit', () => {
            const offset = getHitOffset(100, 100, 100);
            expect(offset).toBeCloseTo(0, 2);
        });

        it('should return 1 for right edge', () => {
            const offset = getHitOffset(150, 100, 100);
            expect(offset).toBeCloseTo(1, 1);
        });

        it('should return -1 for left edge', () => {
            const offset = getHitOffset(50, 100, 100);
            expect(offset).toBeCloseTo(-1, 1);
        });

        it('should clamp values beyond edges', () => {
            const offset = getHitOffset(200, 100, 100);
            expect(offset).toBe(1);
        });
    });
});
</file>

<file path="tests/unit/util/scoring.spec.ts">
/**
 * Tests for Combo Scoring System
 */

import { describe, it, expect, beforeEach } from 'vitest';
import {
    createScoring,
    awardBrickPoints,
    decayCombo,
    resetCombo,
    getComboMultiplier,
    isComboMilestone,
    getScoringDebugInfo,
} from 'util/scoring';

describe('scoring', () => {
    describe('createScoring', () => {
        it('should create initial state with zeros', () => {
            const state = createScoring();
            expect(state.score).toBe(0);
            expect(state.combo).toBe(0);
            expect(state.comboTimer).toBe(0);
        });
    });

    describe('awardBrickPoints', () => {
        it('should award base points with no combo', () => {
            const state = createScoring();
            const points = awardBrickPoints(state, { basePoints: 10 });

            expect(points).toBe(10);
            expect(state.score).toBe(10);
            expect(state.combo).toBe(1);
            expect(state.comboTimer).toBeGreaterThan(0);
        });

        it('should apply multiplier at combo threshold', () => {
            const state = createScoring();
            state.combo = 7; // Just below threshold

            const points1 = awardBrickPoints(state, { basePoints: 10, multiplierThreshold: 8 });
            expect(points1).toBe(10); // Still 1x multiplier
            expect(state.combo).toBe(8);

            const points2 = awardBrickPoints(state, { basePoints: 10, multiplierThreshold: 8 });
            expect(points2).toBe(13); // Now 1.25x multiplier (rounded)
            expect(state.combo).toBe(9);
        });

        it('should increase multiplier at higher combos', () => {
            const state = createScoring();
            state.combo = 15;

            const points = awardBrickPoints(state, {
                basePoints: 10,
                multiplierThreshold: 8,
                multiplierPerThreshold: 0.25,
            });

            // Combo becomes 16: floor(15/8) * 0.25 = 0.25, so 1.25x multiplier = 13 points (rounded)
            expect(points).toBe(13);
        });

        it('should reset combo timer on each brick break', () => {
            const state = createScoring();
            state.comboTimer = 0.5;

            awardBrickPoints(state, { comboDecayTime: 2.0 });

            expect(state.comboTimer).toBe(2.0);
        });
    });

    describe('decayCombo', () => {
        it('should decrease timer over time', () => {
            const state = createScoring();
            state.combo = 5;
            state.comboTimer = 1.5;

            decayCombo(state, 0.5);

            expect(state.comboTimer).toBeCloseTo(1.0, 1);
            expect(state.combo).toBe(5); // Combo still active
        });

        it('should reset combo when timer reaches zero', () => {
            const state = createScoring();
            state.combo = 5;
            state.comboTimer = 0.3;

            decayCombo(state, 0.5);

            expect(state.comboTimer).toBe(0);
            expect(state.combo).toBe(0);
        });

        it('should not decay if timer is already zero', () => {
            const state = createScoring();
            state.combo = 0;
            state.comboTimer = 0;

            decayCombo(state, 1.0);

            expect(state.comboTimer).toBe(0);
            expect(state.combo).toBe(0);
        });
    });

    describe('resetCombo', () => {
        it('should immediately reset combo and timer', () => {
            const state = createScoring();
            state.combo = 10;
            state.comboTimer = 1.5;

            resetCombo(state);

            expect(state.combo).toBe(0);
            expect(state.comboTimer).toBe(0);
        });
    });

    describe('getComboMultiplier', () => {
        it('should return 1.0 with no combo', () => {
            const multiplier = getComboMultiplier(0);
            expect(multiplier).toBe(1.0);
        });

        it('should return 1.0 below threshold', () => {
            const multiplier = getComboMultiplier(7, { multiplierThreshold: 8 });
            expect(multiplier).toBe(1.0);
        });

        it('should return 1.25 at first threshold', () => {
            const multiplier = getComboMultiplier(8, {
                multiplierThreshold: 8,
                multiplierPerThreshold: 0.25,
            });
            expect(multiplier).toBe(1.25);
        });

        it('should scale with multiple thresholds', () => {
            const multiplier = getComboMultiplier(20, {
                multiplierThreshold: 8,
                multiplierPerThreshold: 0.25,
            });
            // floor(20/8) = 2, so 1 + 2*0.25 = 1.5
            expect(multiplier).toBe(1.5);
        });
    });

    describe('isComboMilestone', () => {
        it('should return true at exact threshold', () => {
            expect(isComboMilestone(8, 8)).toBe(true);
            expect(isComboMilestone(16, 8)).toBe(true);
        });

        it('should return false between thresholds', () => {
            expect(isComboMilestone(7, 8)).toBe(false);
            expect(isComboMilestone(9, 8)).toBe(false);
        });

        it('should return false at zero', () => {
            expect(isComboMilestone(0, 8)).toBe(false);
        });
    });

    describe('getScoringDebugInfo', () => {
        it('should provide complete debug info', () => {
            const state = createScoring();
            state.score = 150;
            state.combo = 12;
            state.comboTimer = 1.2;

            const info = getScoringDebugInfo(state, { multiplierThreshold: 8 });

            expect(info.score).toBe(150);
            expect(info.combo).toBe(12);
            expect(info.comboTimer).toBe(1.2);
            expect(info.multiplier).toBe(1.25); // floor(12/8) * 0.25 = 0.25, so 1.25
            expect(info.nextMilestone).toBe(16);
            expect(info.comboActive).toBe(true);
        });
    });
});
</file>

<file path="tests/unit/util/speed-regulation.spec.ts">
/**
 * Tests for Speed Regulation Utilities
 */

import { describe, it, expect } from 'vitest';
import { regulateSpeed, isSpeedWithinRange, getSpeedDebugInfo } from 'util/speed-regulation';
import { Bodies, Body, Vector } from 'matter-js';

describe('speed-regulation', () => {
    describe('regulateSpeed', () => {
        it('should boost slow speeds to base speed', () => {
            const body = Bodies.circle(0, 0, 10);
            Body.setVelocity(body, { x: 2, y: 2 }); // Slow

            regulateSpeed(body, {
                baseSpeed: 8,
                maxSpeed: 14,
            });

            const speed = Vector.magnitude(body.velocity);
            expect(speed).toBeCloseTo(8, 1);
        });

        it('should clamp fast speeds to max speed', () => {
            const body = Bodies.circle(0, 0, 10);
            Body.setVelocity(body, { x: 10, y: 10 }); // Fast

            regulateSpeed(body, {
                baseSpeed: 8,
                maxSpeed: 14,
            });

            const speed = Vector.magnitude(body.velocity);
            expect(speed).toBeCloseTo(14, 1);
        });

        it('should maintain speeds within range', () => {
            const body = Bodies.circle(0, 0, 10);
            Body.setVelocity(body, { x: 6, y: 6 }); // 8.49 units/s, above base

            const initialSpeed = Vector.magnitude(body.velocity);
            expect(initialSpeed).toBeCloseTo(8.49, 1);

            regulateSpeed(body, {
                baseSpeed: 8,
                maxSpeed: 14,
            });

            // Speed is above base (8.49 > 8) so it shouldn't change
            const finalSpeed = Vector.magnitude(body.velocity);
            expect(finalSpeed).toBeCloseTo(8.49, 1);
        });

        it('should handle near-zero velocity', () => {
            const body = Bodies.circle(0, 0, 10);
            Body.setVelocity(body, { x: 0.0001, y: 0.0001 });

            regulateSpeed(body, {
                baseSpeed: 8,
                maxSpeed: 14,
            });

            const speed = Vector.magnitude(body.velocity);
            expect(speed).toBeGreaterThan(0);
        });

        it('should preserve velocity direction', () => {
            const body = Bodies.circle(0, 0, 10);
            Body.setVelocity(body, { x: 3, y: 4 }); // 5 units/s at specific angle

            regulateSpeed(body, {
                baseSpeed: 8,
                maxSpeed: 14,
            });

            // Should scale to base speed while preserving direction
            const ratio = body.velocity.y / body.velocity.x;
            expect(ratio).toBeCloseTo(4 / 3, 1);
        });
    });

    describe('isSpeedWithinRange', () => {
        it('should return true for speed within range', () => {
            const body = Bodies.circle(0, 0, 10);
            Body.setVelocity(body, { x: 6, y: 6 }); // 8.49 units/s

            const result = isSpeedWithinRange(body, {
                baseSpeed: 8,
                maxSpeed: 14,
            });

            expect(result).toBe(true); // 8.49 is within [8, 14]
        });

        it('should return false for speed too slow', () => {
            const body = Bodies.circle(0, 0, 10);
            Body.setVelocity(body, { x: 2, y: 2 });

            const result = isSpeedWithinRange(body, {
                baseSpeed: 8,
                maxSpeed: 14,
            });

            expect(result).toBe(false);
        });

        it('should return false for speed too fast', () => {
            const body = Bodies.circle(0, 0, 10);
            Body.setVelocity(body, { x: 12, y: 12 });

            const result = isSpeedWithinRange(body, {
                baseSpeed: 8,
                maxSpeed: 14,
            });

            expect(result).toBe(false);
        });
    });

    describe('getSpeedDebugInfo', () => {
        it('should provide accurate debug information', () => {
            const body = Bodies.circle(0, 0, 10);
            Body.setVelocity(body, { x: 3, y: 4 }); // 5 units/s

            const info = getSpeedDebugInfo(body, {
                baseSpeed: 8,
                maxSpeed: 14,
            });

            expect(info.currentSpeed).toBeCloseTo(5, 1);
            expect(info.baseSpeed).toBe(8);
            expect(info.maxSpeed).toBe(14);
            expect(info.isTooSlow).toBe(true);
            expect(info.isTooFast).toBe(false);
            expect(info.isWithinRange).toBe(false);
        });
    });
});
</file>

<file path=".github/copilot-instructions.md">
# lucky-break Development Guidelines

Auto-generated from all feature plans. Last updated: 2025-10-15

## Active Technologies
- TypeScript 5.x (strict mode) + PixiJS 8, Matter.js 0.19, Tone.js 14, Vite 7 build tooling (001-we-re-building)
- N/A (session lives entirely in memory; no persistent datastore) (001-we-re-building)
- TypeScript 5.x (strict mode) + PixiJS 8, Matter.js 0.19, Vite 7 (002-when-i-click)

## Project Structure
```
src/
├── app/
├── physics/
├── render/
├── audio/
├── util/
└── cli/

tests/
└── unit/
```

## Commands
pnpm test

## Code Style
TypeScript 5.x (strict mode): Follow standard conventions

## Recent Changes
- 002-when-i-click: Added TypeScript 5.x (strict mode) + PixiJS 8, Matter.js 0.19, Vite 7
- 001-we-re-building: Added TypeScript 5.x (strict mode) + PixiJS 8, Matter.js 0.19, Tone.js 14, Vite 7
- 001-we-re-building: Added TypeScript 5.x (strict mode) + PixiJS 8, Matter.js 0.19, Tone.js 14, Vite 7

<!-- MANUAL ADDITIONS START -->
<!-- MANUAL ADDITIONS END -->
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Lucky Break</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/app/main.ts"></script>
  </body>
</html>
</file>

<file path="src/app/events.ts">
export type BrickType = 'standard' | 'multi-hit' | 'indestructible' | 'power-up';
export type WallHitSide = 'top' | 'left' | 'right';
export type LifeLostCause = 'ball-drop' | 'timeout' | 'forced-reset';

export interface BrickBreakPayload {
    readonly sessionId: string;
    readonly row: number;
    readonly col: number;
    readonly velocity: number;
    readonly brickType: BrickType;
    readonly comboHeat: number;
}

export interface PaddleHitPayload {
    readonly sessionId: string;
    readonly angle: number;
    readonly speed: number;
    readonly impactOffset: number;
}

export interface WallHitPayload {
    readonly sessionId: string;
    readonly side: WallHitSide;
    readonly speed: number;
}

export interface LifeLostPayload {
    readonly sessionId: string;
    readonly livesRemaining: number;
    readonly cause: LifeLostCause;
}

export interface RoundCompletedPayload {
    readonly sessionId: string;
    readonly round: number;
    readonly scoreAwarded: number;
    readonly durationMs: number;
}

export type LuckyBreakEventMap = {
    readonly BrickBreak: BrickBreakPayload;
    readonly PaddleHit: PaddleHitPayload;
    readonly WallHit: WallHitPayload;
    readonly LifeLost: LifeLostPayload;
    readonly RoundCompleted: RoundCompletedPayload;
};

export type LuckyBreakEventName = keyof LuckyBreakEventMap;

export interface EventEnvelope<EventName extends LuckyBreakEventName> {
    readonly type: EventName;
    readonly timestamp: number;
    readonly payload: LuckyBreakEventMap[EventName];
}

export type EventListener<EventName extends LuckyBreakEventName> = (
    event: EventEnvelope<EventName>,
) => void;

export interface LuckyBreakEventBus {
    publish<EventName extends LuckyBreakEventName>(
        type: EventName,
        payload: LuckyBreakEventMap[EventName],
        timestamp?: number,
    ): void;
    subscribe<EventName extends LuckyBreakEventName>(
        type: EventName,
        listener: EventListener<EventName>,
    ): () => void;
    subscribeOnce<EventName extends LuckyBreakEventName>(
        type: EventName,
        listener: EventListener<EventName>,
    ): () => void;
    unsubscribe<EventName extends LuckyBreakEventName>(
        type: EventName,
        listener: EventListener<EventName>,
    ): void;
    clear(): void;
    listeners<EventName extends LuckyBreakEventName>(type: EventName): readonly EventListener<EventName>[];
}

export interface BrickBreakEventInput {
    readonly sessionId: string;
    readonly row: number;
    readonly col: number;
    readonly velocity: number;
    readonly brickType: BrickType;
    readonly comboHeat: number;
    readonly timestamp?: number;
}

export interface RoundCompletedEventInput {
    readonly sessionId: string;
    readonly round: number;
    readonly scoreAwarded: number;
    readonly durationMs: number;
    readonly timestamp?: number;
}

export interface ScoringEventEmitter {
    readonly brickBreak: (event: BrickBreakEventInput) => void;
    readonly roundCompleted: (event: RoundCompletedEventInput) => void;
}

type InternalListener = EventListener<LuckyBreakEventName>;

type ListenerRegistry = Map<LuckyBreakEventName, Set<InternalListener>>;

const ensureListenerSet = (registry: ListenerRegistry, type: LuckyBreakEventName): Set<InternalListener> => {
    const existing = registry.get(type);
    if (existing) {
        return existing;
    }

    const created = new Set<InternalListener>();
    registry.set(type, created);
    return created;
};

const toEnvelope = <EventName extends LuckyBreakEventName>(
    type: EventName,
    payload: LuckyBreakEventMap[EventName],
    timestamp: number,
): EventEnvelope<EventName> => ({
    type,
    payload,
    timestamp,
});

export const createEventBus = (): LuckyBreakEventBus => {
    const registry: ListenerRegistry = new Map();

    const publish: LuckyBreakEventBus['publish'] = (type, payload, timestamp = Date.now()) => {
        const listeners = registry.get(type);
        if (!listeners || listeners.size === 0) {
            return;
        }

        const envelope = toEnvelope(type, payload, timestamp);
        for (const listener of listeners) {
            listener(envelope);
        }
    };

    const unsubscribe: LuckyBreakEventBus['unsubscribe'] = (type, listener) => {
        const listeners = registry.get(type);
        if (!listeners) {
            return;
        }

        listeners.delete(listener as InternalListener);
        if (listeners.size === 0) {
            registry.delete(type);
        }
    };

    const subscribe: LuckyBreakEventBus['subscribe'] = (type, listener) => {
        const listeners = ensureListenerSet(registry, type);
        listeners.add(listener as InternalListener);
        return () => unsubscribe(type, listener);
    };

    const subscribeOnceInternal = <EventName extends LuckyBreakEventName>(
        type: EventName,
        listener: EventListener<EventName>,
    ): (() => void) => {
        let unsubscribeRef: (() => void) | undefined;
        const wrapped: EventListener<EventName> = (event) => {
            unsubscribeRef?.();
            listener(event);
        };
        unsubscribeRef = subscribe(type, wrapped);
        return unsubscribeRef;
    };

    const subscribeOnce = subscribeOnceInternal as LuckyBreakEventBus['subscribeOnce'];

    const clear: LuckyBreakEventBus['clear'] = () => {
        registry.clear();
    };

    const listeners: LuckyBreakEventBus['listeners'] = (type) => {
        const listenersForType = registry.get(type);
        if (!listenersForType) {
            return [];
        }

        return Array.from(listenersForType) as EventListener<typeof type>[];
    };

    return {
        publish,
        subscribe,
        subscribeOnce,
        unsubscribe,
        clear,
        listeners,
    };
};

export const createScoringEventEmitter = (bus: LuckyBreakEventBus): ScoringEventEmitter => {
    const publishBrickBreak: ScoringEventEmitter['brickBreak'] = (event) => {
        bus.publish(
            'BrickBreak',
            {
                sessionId: event.sessionId,
                row: event.row,
                col: event.col,
                velocity: event.velocity,
                brickType: event.brickType,
                comboHeat: event.comboHeat,
            },
            event.timestamp,
        );
    };

    const publishRoundCompleted: ScoringEventEmitter['roundCompleted'] = (event) => {
        bus.publish(
            'RoundCompleted',
            {
                sessionId: event.sessionId,
                round: event.round,
                scoreAwarded: event.scoreAwarded,
                durationMs: event.durationMs,
            },
            event.timestamp,
        );
    };

    return {
        brickBreak: publishBrickBreak,
        roundCompleted: publishRoundCompleted,
    };
};
</file>

<file path="src/app/state.ts">
import {
    type BrickType,
    type LifeLostCause,
    type LuckyBreakEventBus,
    createScoringEventEmitter,
} from './events';

export type GameStatus = 'pending' | 'active' | 'paused' | 'completed' | 'failed';

export interface MomentumMetrics {
    readonly volleyLength: number;
    readonly speedPressure: number;
    readonly brickDensity: number;
    readonly comboHeat: number;
    readonly comboTimer: number; // Time remaining before combo resets (in seconds)
    readonly updatedAt: number;
}

export interface AudioState {
    readonly scene: 'calm' | 'focused' | 'tense' | 'climax';
    readonly nextScene: 'calm' | 'focused' | 'tense' | 'climax' | null;
    readonly barCountdown: number;
    readonly sends: {
        readonly reverb: number;
        readonly delay: number;
    };
    readonly primaryLayerActive: boolean;
}

export interface PlayerPreferences {
    readonly masterVolume: number;
    readonly muted: boolean;
    readonly reducedMotion: boolean;
    readonly controlScheme: 'touch' | 'mouse' | 'keyboard';
    readonly controlSensitivity: number;
}

export type HudPromptSeverity = 'info' | 'warning' | 'error';

export interface HudPrompt {
    readonly id: string;
    readonly severity: HudPromptSeverity;
    readonly message: string;
}

export interface HudSnapshot {
    readonly score: number;
    readonly lives: number;
    readonly round: number;
    readonly brickRemaining: number;
    readonly brickTotal: number;
    readonly momentum: Omit<MomentumMetrics, 'updatedAt'>;
    readonly audio: Pick<AudioState, 'scene' | 'nextScene' | 'barCountdown'>;
    readonly prompts: readonly HudPrompt[];
    readonly settings: {
        readonly muted: boolean;
        readonly masterVolume: number;
        readonly reducedMotion: boolean;
    };
}

export interface RoundOutcome {
    readonly result: 'win' | 'loss';
    readonly round: number;
    readonly scoreAwarded: number;
    readonly durationMs: number;
    readonly timestamp: number;
    readonly cause?: LifeLostCause;
}

export interface GameSessionSnapshot {
    readonly sessionId: string;
    readonly status: GameStatus;
    readonly score: number;
    readonly livesRemaining: number;
    readonly round: number;
    readonly elapsedTimeMs: number;
    readonly brickTotal: number;
    readonly brickRemaining: number;
    readonly lastOutcome?: RoundOutcome;
    readonly momentum: MomentumMetrics;
    readonly audio: AudioState;
    readonly preferences: PlayerPreferences;
    readonly hud: HudSnapshot;
    readonly updatedAt: number;
}

interface StartRoundConfig {
    readonly breakableBricks: number;
}

interface BrickBreakDetails {
    readonly points: number;
    readonly event?: {
        readonly row: number;
        readonly col: number;
        readonly velocity: number;
        readonly brickType: BrickType;
    };
}

export interface GameSessionManager {
    readonly snapshot: () => GameSessionSnapshot;
    readonly startRound: (config: StartRoundConfig) => void;
    readonly recordBrickBreak: (details: BrickBreakDetails) => void;
    readonly recordLifeLost: (cause: LifeLostCause) => void;
    readonly completeRound: () => void;
}

export interface GameSessionOptions {
    readonly sessionId?: string;
    readonly initialLives?: number;
    readonly now?: () => number;
    readonly preferences?: Partial<PlayerPreferences>;
    readonly eventBus?: LuckyBreakEventBus;
}

const DEFAULT_LIVES = 3;

const INITIAL_PREFERENCES: PlayerPreferences = {
    masterVolume: 1,
    muted: false,
    reducedMotion: false,
    controlScheme: 'keyboard',
    controlSensitivity: 0.5,
};

const clamp01 = (value: number): number => Math.max(0, Math.min(1, value));

type Mutable<T> = { -readonly [Key in keyof T]: T[Key] };

const createPrompts = (status: GameStatus): readonly HudPrompt[] => {
    switch (status) {
        case 'pending':
            return [
                {
                    id: 'round-pending',
                    severity: 'info',
                    message: 'Tap to start the round',
                },
            ];
        case 'active':
            return [
                {
                    id: 'round-active',
                    severity: 'info',
                    message: 'Round in progress',
                },
            ];
        case 'paused':
            return [
                {
                    id: 'round-paused',
                    severity: 'warning',
                    message: 'Paused — resume when ready',
                },
            ];
        case 'completed':
            return [
                {
                    id: 'round-complete',
                    severity: 'info',
                    message: 'Round complete — tap to continue',
                },
            ];
        case 'failed':
            return [
                {
                    id: 'round-failed',
                    severity: 'error',
                    message: 'All lives lost — press retry',
                },
            ];
        default:
            return [];
    }
};

const cloneMomentum = (momentum: MomentumMetrics): MomentumMetrics => ({ ...momentum });

const cloneAudio = (audio: AudioState): AudioState => ({
    scene: audio.scene,
    nextScene: audio.nextScene,
    barCountdown: audio.barCountdown,
    sends: { ...audio.sends },
    primaryLayerActive: audio.primaryLayerActive,
});

const clonePreferences = (preferences: PlayerPreferences): PlayerPreferences => ({ ...preferences });

const toHudSnapshot = (
    state: Omit<GameSessionSnapshot, 'hud' | 'elapsedTimeMs' | 'updatedAt'>,
    elapsedTimeMs: number,
): HudSnapshot => ({
    score: state.score,
    lives: state.livesRemaining,
    round: state.round,
    brickRemaining: state.brickRemaining,
    brickTotal: state.brickTotal,
    momentum: {
        volleyLength: state.momentum.volleyLength,
        speedPressure: state.momentum.speedPressure,
        brickDensity: state.momentum.brickDensity,
        comboHeat: state.momentum.comboHeat,
        comboTimer: state.momentum.comboTimer,
    },
    audio: {
        scene: state.audio.scene,
        nextScene: state.audio.nextScene,
        barCountdown: state.audio.barCountdown,
    },
    prompts: createPrompts(state.status),
    settings: {
        muted: state.preferences.muted,
        masterVolume: state.preferences.masterVolume,
        reducedMotion: state.preferences.reducedMotion,
    },
});

export const createGameSessionManager = (options: GameSessionOptions = {}): GameSessionManager => {
    const now = options.now ?? Date.now;
    const sessionId = options.sessionId ?? `session-${Math.random().toString(16).slice(2)}`;
    const preferences: PlayerPreferences = { ...INITIAL_PREFERENCES, ...options.preferences };
    const scoringEvents = options.eventBus ? createScoringEventEmitter(options.eventBus) : undefined;

    let status: GameStatus = 'pending';
    let score = 0;
    const initialLives = Math.max(0, options.initialLives ?? DEFAULT_LIVES);
    let livesRemaining = initialLives;
    let round = 1;
    let brickTotal = 0;
    let brickRemaining = 0;
    let lastOutcome: RoundOutcome | undefined;
    let startedAt: number | undefined;
    let elapsedMs = 0;

    const momentum: Mutable<MomentumMetrics> = {
        volleyLength: 0,
        speedPressure: 0,
        brickDensity: 1,
        comboHeat: 0,
        comboTimer: 0,
        updatedAt: now(),
    };

    const audio: AudioState = {
        scene: 'calm',
        nextScene: null,
        barCountdown: 0,
        sends: {
            reverb: 0,
            delay: 0,
        },
        primaryLayerActive: false,
    };

    const computeElapsed = (timestamp: number): number => {
        if (status === 'active' && startedAt !== undefined) {
            return timestamp - startedAt;
        }

        return elapsedMs;
    };

    const snapshot: GameSessionManager['snapshot'] = () => {
        const timestamp = now();
        const currentElapsed = computeElapsed(timestamp);

        const base: Omit<GameSessionSnapshot, 'hud' | 'updatedAt' | 'elapsedTimeMs'> = {
            sessionId,
            status,
            score,
            livesRemaining,
            round,
            brickTotal,
            brickRemaining,
            lastOutcome,
            momentum: cloneMomentum(momentum),
            audio: cloneAudio(audio),
            preferences: clonePreferences(preferences),
        };

        const hud = toHudSnapshot(base, currentElapsed);

        return {
            ...base,
            elapsedTimeMs: currentElapsed,
            hud,
            updatedAt: timestamp,
        };
    };

    const startRound: GameSessionManager['startRound'] = ({ breakableBricks }) => {
        const timestamp = now();
        status = 'active';
        round = Math.max(1, round);
        brickTotal = Math.max(0, breakableBricks);
        brickRemaining = brickTotal;
        startedAt = timestamp;
        elapsedMs = 0;
        momentum.volleyLength = 0;
        momentum.comboHeat = 0;
        momentum.comboTimer = 0;
        momentum.speedPressure = 0;
        momentum.brickDensity = brickTotal === 0 ? 0 : 1;
        momentum.updatedAt = timestamp;
        lastOutcome = undefined;
    };

    const recordBrickBreak: GameSessionManager['recordBrickBreak'] = ({ points, event }) => {
        if (status !== 'active') {
            return;
        }

        const timestamp = now();
        score = Math.max(0, score + points);
        if (brickRemaining > 0) {
            brickRemaining = Math.max(0, brickRemaining - 1);
        }

        momentum.volleyLength += 1;
        momentum.comboHeat = Math.min(99, momentum.comboHeat + 1);
        momentum.speedPressure = clamp01(momentum.speedPressure + 0.08);
        momentum.brickDensity = brickTotal === 0 ? 0 : brickRemaining / brickTotal;
        momentum.updatedAt = timestamp;

        if (scoringEvents && event) {
            scoringEvents.brickBreak({
                sessionId,
                row: event.row,
                col: event.col,
                velocity: event.velocity,
                brickType: event.brickType,
                comboHeat: momentum.comboHeat,
                timestamp,
            });
        }
    };

    const recordLifeLost: GameSessionManager['recordLifeLost'] = (cause) => {
        if (status !== 'active') {
            return;
        }

        const timestamp = now();
        if (livesRemaining > 0) {
            livesRemaining -= 1;
        }

        momentum.volleyLength = 0;
        momentum.comboHeat = 0;
        momentum.comboTimer = 0;
        momentum.speedPressure = clamp01(momentum.speedPressure * 0.5);
        momentum.updatedAt = timestamp;

        if (livesRemaining <= 0) {
            status = 'failed';
            elapsedMs = startedAt !== undefined ? timestamp - startedAt : 0;
            lastOutcome = {
                result: 'loss',
                round,
                scoreAwarded: score,
                durationMs: elapsedMs,
                timestamp,
                cause,
            };
        }
    };

    const completeRound: GameSessionManager['completeRound'] = () => {
        if (status !== 'active') {
            return;
        }

        const timestamp = now();
        status = 'completed';
        brickRemaining = 0;
        elapsedMs = startedAt !== undefined ? timestamp - startedAt : 0;
        lastOutcome = {
            result: 'win',
            round,
            scoreAwarded: score,
            durationMs: elapsedMs,
            timestamp,
        };

        scoringEvents?.roundCompleted({
            sessionId,
            round,
            scoreAwarded: score,
            durationMs: elapsedMs,
            timestamp,
        });
    }; // Round outcome stored for HUD summary

    return {
        snapshot,
        startRound,
        recordBrickBreak,
        recordLifeLost,
        completeRound,
    };
};
</file>

<file path="src/cli/index.ts">
import { runHeadlessSimulation } from './simulate';

export interface CliCommand {
    readonly execute: () => Promise<number>;
}

const parseArgs = (args: string[]): { seed?: number; round?: number; durationSec?: number } => {
    const options: { seed?: number; round?: number; durationSec?: number } = {};
    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (arg === '--seed' && i + 1 < args.length) {
            options.seed = parseInt(args[i + 1], 10);
            i++;
        } else if (arg === '--round' && i + 1 < args.length) {
            options.round = parseInt(args[i + 1], 10);
            i++;
        } else if (arg === '--duration' && i + 1 < args.length) {
            options.durationSec = parseInt(args[i + 1], 10);
            i++;
        }
    }
    return options;
};

export function createCli(): CliCommand {
    const execute = async (): Promise<number> => {
        const args = process.argv.slice(2);
        if (args.length === 0 || args[0] !== 'simulate') {
            console.error('Usage: lucky-break simulate --seed <number> --round <number> --duration <seconds>');
            return 1;
        }

        const options = parseArgs(args.slice(1));
        const input = {
            mode: 'simulate' as const,
            ...options,
        };

        try {
            const result = await runHeadlessSimulation(input);
            console.log(JSON.stringify(result));
            return 0;
        } catch (error) {
            console.error(`Simulation failed: ${(error as Error).message}`);
            return 1;
        }
    };

    return {
        execute,
    };
}
</file>

<file path="tests/setup/vitest.setup.ts">
import '@testing-library/jest-dom/vitest';
import { afterEach, vi } from 'vitest';

afterEach(() => {
    document.body.innerHTML = '';
    document.head.innerHTML = '';
});

if (typeof globalThis.requestAnimationFrame === 'undefined') {
    const raf = (callback: FrameRequestCallback): number => {
        return setTimeout(() => {
            callback(performance.now());
        }, 16) as unknown as number;
    };

    vi.stubGlobal('requestAnimationFrame', raf);
}

if (typeof globalThis.cancelAnimationFrame === 'undefined') {
    const cancelRaf = (handle: number): void => {
        clearTimeout(handle);
    };

    vi.stubGlobal('cancelAnimationFrame', cancelRaf);
}

if (typeof HTMLCanvasElement !== 'undefined' && !HTMLCanvasElement.prototype.getContext) {
    (HTMLCanvasElement.prototype.getContext as unknown) = vi.fn(() => null);
}

// Mock Touch API for testing
if (typeof globalThis.Touch === 'undefined') {
    globalThis.Touch = class Touch {
        readonly identifier: number;
        readonly target: EventTarget;
        readonly clientX: number;
        readonly clientY: number;
        readonly screenX: number;
        readonly screenY: number;
        readonly pageX: number;
        readonly pageY: number;

        constructor(options: {
            identifier: number;
            target: EventTarget;
            clientX?: number;
            clientY?: number;
            screenX?: number;
            screenY?: number;
            pageX?: number;
            pageY?: number;
        }) {
            this.identifier = options.identifier;
            this.target = options.target;
            this.clientX = options.clientX ?? 0;
            this.clientY = options.clientY ?? 0;
            this.screenX = options.screenX ?? 0;
            this.screenY = options.screenY ?? 0;
            this.pageX = options.pageX ?? 0;
            this.pageY = options.pageY ?? 0;
        }
    } as any;
}
</file>

<file path="tests/unit/bootstrap.spec.ts">
import { describe, expect, it } from 'vitest';
import { bootstrapLuckyBreak } from '@app/main';

describe('bootstrapLuckyBreak', () => {
    it('initializes without throwing', () => {
        const container = document.createElement('div');
        expect(() => bootstrapLuckyBreak({ container })).not.toThrow();
    });
});
</file>

<file path="tests/unit/physics/ball-launch.spec.ts">
/**
 * Ball Launch Mechanics Test Suite
 *
 * Feature: Paddle Control and Ball Launch
 * Date: 2025-10-15
 * Purpose: Test ball launch velocity application and detachment
 */

import { describe, it, expect, beforeEach } from 'vitest';
import { Bodies } from 'matter-js';
import type { BallController, Ball, Vector2 } from 'physics/contracts';
import { createPhysicsWorld } from 'physics/world';

describe('Ball Launch Mechanics', () => {
    let world: ReturnType<typeof createPhysicsWorld>;
    let ballController: BallController;
    let mockBall: Ball;

    beforeEach(() => {
        world = createPhysicsWorld();
        mockBall = {
            id: 'test-ball',
            physicsBody: world.factory.ball({ radius: 8, position: { x: 400, y: 350 } }),
            isAttached: true,
            attachmentOffset: { x: 0, y: -10 },
            radius: 8,
        };

        world.add(mockBall.physicsBody);
        world.add(world.factory.bounds()); // Add world boundaries

        // Mock ball controller - in real implementation this would be the actual class
        ballController = {
            createAttachedBall: (paddlePosition: Vector2) => mockBall,
            updateAttachment: (ball: Ball, paddlePosition: Vector2) => {
                if (ball.isAttached) {
                    world.updateBallAttachment(ball.physicsBody, paddlePosition);
                }
            },
            launchBall: (ball: Ball, direction: Vector2 = { x: 0, y: -1 }) => {
                // Detach from paddle if attached
                if (ball.isAttached) {
                    world.detachBallFromPaddle(ball.physicsBody);
                }
                ball.isAttached = false;

                const speed = 300;
                const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y);
                const normalizedDirection = length > 0 ? {
                    x: direction.x / length,
                    y: direction.y / length,
                } : { x: 0, y: -1 };

                ball.physicsBody.velocity.x = normalizedDirection.x * speed;
                ball.physicsBody.velocity.y = normalizedDirection.y * speed;
            },
            isAttached: (ball: Ball) => world.isBallAttached(ball.physicsBody),
            resetToAttached: (ball: Ball, paddlePosition: Vector2) => {
                const paddle = world.factory.paddle({
                    position: { x: paddlePosition.x, y: paddlePosition.y + 50 }, // Position paddle below ball to avoid overlap
                    size: { width: 100, height: 20 },
                });
                world.attachBallToPaddle(ball.physicsBody, paddle, ball.attachmentOffset);
                ball.isAttached = true;
            },
            getDebugInfo: (ball: Ball) => ({
                position: ball.physicsBody.position,
                velocity: ball.physicsBody.velocity,
                isAttached: ball.isAttached,
                attachmentOffset: ball.attachmentOffset,
                physicsBodyId: ball.physicsBody.id,
            }),
        };
    });

    describe('Ball Launch Velocity', () => {
        it('should apply upward velocity on launch', () => {
            const initialVelocity = { ...mockBall.physicsBody.velocity };

            // Launch with default upward direction
            ballController.launchBall(mockBall);

            expect(mockBall.physicsBody.velocity.y).toBeLessThan(initialVelocity.y);
            expect(mockBall.physicsBody.velocity.y).toBe(-300); // Default upward speed
            expect(mockBall.isAttached).toBe(false);
        });

        it('should apply custom launch direction', () => {
            const direction: Vector2 = { x: 1, y: -1 }; // 45 degrees upward-right

            ballController.launchBall(mockBall, direction);

            const expectedSpeed = 300;
            const expectedX = (1 / Math.sqrt(2)) * expectedSpeed; // cos(45°) * speed
            const expectedY = (-1 / Math.sqrt(2)) * expectedSpeed; // -sin(45°) * speed

            expect(mockBall.physicsBody.velocity.x).toBeCloseTo(expectedX, 1);
            expect(mockBall.physicsBody.velocity.y).toBeCloseTo(expectedY, 1);
        });

        it('should normalize direction vector', () => {
            const direction: Vector2 = { x: 3, y: -4 }; // Not normalized

            ballController.launchBall(mockBall, direction);

            const speed = Math.sqrt(
                mockBall.physicsBody.velocity.x ** 2 +
                mockBall.physicsBody.velocity.y ** 2
            );

            expect(speed).toBeCloseTo(300, 1);
        });

        it('should handle zero direction vector', () => {
            const direction: Vector2 = { x: 0, y: 0 };

            ballController.launchBall(mockBall, direction);

            // Should default to upward
            expect(mockBall.physicsBody.velocity.x).toBe(0);
            expect(mockBall.physicsBody.velocity.y).toBe(-300);
        });
    });

    describe('Ball Detachment on Launch', () => {
        it('should detach ball from paddle on launch', () => {
            // Attach ball first
            const paddlePosition: Vector2 = { x: 400, y: 350 };
            ballController.resetToAttached(mockBall, paddlePosition);

            expect(ballController.isAttached(mockBall)).toBe(true);

            // Launch
            ballController.launchBall(mockBall);

            expect(ballController.isAttached(mockBall)).toBe(false);
        });

        it('should allow ball to move freely after launch', () => {
            const initialPosition = { ...mockBall.physicsBody.position };

            ballController.launchBall(mockBall);

            // Step physics to allow movement
            world.step(1000 / 60);

            const newPosition = mockBall.physicsBody.position;
            const deltaX = Math.abs(newPosition.x - initialPosition.x);
            const deltaY = Math.abs(newPosition.y - initialPosition.y);

            expect(deltaX + deltaY).toBeGreaterThan(0.1); // Should have moved
        });

        it('should maintain launch velocity over time', () => {
            const initialVelocity = { ...mockBall.physicsBody.velocity };

            ballController.launchBall(mockBall, { x: 0.5, y: -0.866 }); // 60 degrees

            // Step physics multiple times with default time step
            for (let i = 0; i < 10; i++) {
                world.step();
            }

            // Velocity should be mostly preserved (some air resistance)
            const currentVelocity = mockBall.physicsBody.velocity;
            const speed = Math.sqrt(currentVelocity.x ** 2 + currentVelocity.y ** 2);

            expect(speed).toBeGreaterThan(1); // Should retain some launch speed
        });
    });

    describe('Launch State Transitions', () => {
        it('should transition from attached to launched state', () => {
            const paddlePosition: Vector2 = { x: 400, y: 350 };

            // Start attached
            ballController.resetToAttached(mockBall, paddlePosition);
            expect(ballController.isAttached(mockBall)).toBe(true);
            expect(mockBall.physicsBody.velocity.x).toBe(0);
            expect(mockBall.physicsBody.velocity.y).toBe(0);

            // Launch
            ballController.launchBall(mockBall);
            expect(ballController.isAttached(mockBall)).toBe(false);
            expect(mockBall.physicsBody.velocity.y).toBe(-300);
        });

        it('should handle multiple launch cycles', () => {
            const paddlePosition: Vector2 = { x: 400, y: 350 };

            // First launch
            ballController.launchBall(mockBall);
            expect(ballController.isAttached(mockBall)).toBe(false);

            // Reset to attached
            ballController.resetToAttached(mockBall, paddlePosition);
            expect(ballController.isAttached(mockBall)).toBe(true);

            // Second launch
            ballController.launchBall(mockBall);
            expect(ballController.isAttached(mockBall)).toBe(false);
        });

        it('should provide debug info after launch', () => {
            ballController.launchBall(mockBall);

            const debugInfo = ballController.getDebugInfo(mockBall);

            expect(debugInfo.isAttached).toBe(false);
            expect(debugInfo.velocity.y).toBe(-300);
            expect(debugInfo.velocity.x).toBe(0);
        });
    });

    describe('Launch Physics Integration', () => {
        it('should respect physics world constraints', () => {
            // Launch ball toward a boundary
            ballController.launchBall(mockBall, { x: -1, y: 0 }); // Leftward

            // Step physics - ball should bounce off left wall
            for (let i = 0; i < 120; i++) { // 2 seconds at default fps
                world.step();
            }

            // Ball should have some horizontal velocity (may have bounced or not)
            expect(Math.abs(mockBall.physicsBody.velocity.x)).toBeGreaterThanOrEqual(0);
        });

        it('should apply restitution on bounces', () => {
            ballController.launchBall(mockBall, { x: 0, y: -1 });

            // Let ball hit ceiling and bounce
            for (let i = 0; i < 180; i++) { // 3 seconds
                world.step();
            }

            const finalSpeed = Math.sqrt(
                mockBall.physicsBody.velocity.x ** 2 +
                mockBall.physicsBody.velocity.y ** 2
            );

            // Ball should have some speed after bouncing (exact value depends on physics simulation)
            expect(finalSpeed).toBeGreaterThan(0);
        });
    });
});
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import { URL, fileURLToPath } from "node:url";

const resolveFromRoot = (relativePath: string) =>
    fileURLToPath(new URL(relativePath, import.meta.url));

export default defineConfig({
    appType: "spa",
    build: {
        outDir: "dist",
        sourcemap: true,
        rollupOptions: {
            input: resolveFromRoot("./src/app/main.ts")
        }
    },
    resolve: {
        alias: {
            "app": resolveFromRoot("./src/app"),
            "physics": resolveFromRoot("./src/physics"),
            "render": resolveFromRoot("./src/render"),
            "audio": resolveFromRoot("./src/audio"),
            "util": resolveFromRoot("./src/util"),
            "cli": resolveFromRoot("./src/cli"),
            "input": resolveFromRoot("./src/input"),
            "types": resolveFromRoot("./src/types")
        }
    },
    server: {
        port: 5173,
        strictPort: true
    }
});
</file>

<file path="src/render/stage.ts">
import { Application, Container, Sprite } from 'pixi.js';

const DEFAULT_WIDTH = 1280;
const DEFAULT_HEIGHT = 720;

export interface StageConfig {
    readonly view?: HTMLCanvasElement;
    readonly parent?: HTMLElement;
    readonly width?: number;
    readonly height?: number;
    readonly background?: number;
    readonly resolution?: number;
}

export interface StageLayers {
    readonly root: Container;
    readonly playfield: Container;
    readonly effects: Container;
    readonly hud: Container;
}

type StageLayerName = 'playfield' | 'effects' | 'hud';

interface SpritePool<T> {
    acquire: () => T;
    release: (value: T) => void;
    clear: () => void;
}

const createSpritePool = <T>(factory: () => T): SpritePool<T> => {
    const free: T[] = [];

    return {
        acquire: () => free.pop() ?? factory(),
        release: (value) => {
            free.push(value);
        },
        clear: () => {
            free.length = 0;
        },
    };
};

const resizeRenderer = (app: Application, width: number, height: number): void => {
    const renderer = app.renderer as unknown as { resize?: (...args: unknown[]) => void };
    const resize = renderer.resize;

    if (typeof resize === 'function') {
        if (resize.length <= 1) {
            resize.call(renderer, { width, height });
            return;
        }

        resize.call(renderer, width, height);
    }
};

export interface StageHandle {
    readonly app: Application;
    readonly canvas: HTMLCanvasElement;
    readonly layers: StageLayers;
    readonly acquireSprite: () => Sprite;
    readonly releaseSprite: (sprite: Sprite) => void;
    readonly addToLayer: (layer: StageLayerName, displayObject: Container) => void;
    readonly removeFromLayer: (displayObject: Container) => void;
    readonly resize: (size: { readonly width: number; readonly height: number }) => void;
    readonly destroy: () => void;
}

const DEFAULT_BACKGROUND = 0x000000;

const resolveResolution = (config: StageConfig): number => {
    if (config.resolution) {
        return config.resolution;
    }

    if (typeof window !== 'undefined' && typeof window.devicePixelRatio === 'number') {
        return window.devicePixelRatio;
    }

    return 1;
};

export const createStage = async (config: StageConfig = {}): Promise<StageHandle> => {
    const width = config.width ?? DEFAULT_WIDTH;
    const height = config.height ?? DEFAULT_HEIGHT;
    const resolution = resolveResolution(config);

    const app = new Application();
    await app.init({
        width,
        height,
        canvas: config.view,
        resolution,
        antialias: true,
    });

    if (config.background !== undefined) {
        app.renderer.background.color = config.background;
    } else {
        app.renderer.background.color = DEFAULT_BACKGROUND;
    }

    const canvas = app.canvas as HTMLCanvasElement;
    let detachOnDestroy = false;

    if (config.parent) {
        const alreadyAttached = canvas.parentElement === config.parent;
        if (!alreadyAttached) {
            config.parent.appendChild(canvas);
            detachOnDestroy = true;
        }
    }

    const root = app.stage;
    root.sortableChildren = true;

    const playfield = new Container();
    playfield.label = 'playfield';
    playfield.zIndex = 10;

    const effects = new Container();
    effects.label = 'effects';
    effects.zIndex = 20;

    const hud = new Container();
    hud.label = 'hud';
    hud.zIndex = 30;

    root.addChild(playfield, effects, hud);

    const layers: StageLayers = {
        root,
        playfield,
        effects,
        hud,
    };

    const spritePool = createSpritePool(() => new Sprite());

    const addToLayer: StageHandle['addToLayer'] = (layerName, displayObject) => {
        const layer = layers[layerName];
        if (!layer.children.includes(displayObject)) {
            layer.addChild(displayObject);
        }
    };

    const removeFromLayer: StageHandle['removeFromLayer'] = (displayObject) => {
        const parent = displayObject.parent;
        if (parent) {
            parent.removeChild(displayObject);
        }
    };

    const acquireSprite: StageHandle['acquireSprite'] = () => {
        const sprite = spritePool.acquire();
        sprite.visible = true;
        sprite.alpha = 1;
        return sprite;
    };

    const releaseSprite: StageHandle['releaseSprite'] = (sprite) => {
        removeFromLayer(sprite);
        sprite.visible = false;
        sprite.alpha = 1;
        spritePool.release(sprite);
    };

    const resize: StageHandle['resize'] = (size) => {
        resizeRenderer(app, size.width, size.height);
    };

    const destroy: StageHandle['destroy'] = () => {
        spritePool.clear();
        if (typeof root.removeChildren === 'function') {
            root.removeChildren();
        }

        if (detachOnDestroy && config.parent?.contains(canvas)) {
            config.parent.removeChild(canvas);
        }

        app.destroy();
    };

    return {
        app,
        canvas,
        layers,
        acquireSprite,
        releaseSprite,
        addToLayer,
        removeFromLayer,
        resize,
        destroy,
    };
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
  "skipLibCheck": true,
    "types": [
      "vite/client",
      "node"
    ],
    "baseUrl": "./",
    "paths": {
      "app/*": ["src/app/*"],
      "physics/*": ["src/physics/*"],
      "render/*": ["src/render/*"],
      "audio/*": ["src/audio/*"],
      "util/*": ["src/util/*"],
      "cli/*": ["src/cli/*"],
      "input/*": ["src/input/*"],
      "types/*": ["src/types/*"]
    }
  },
  "include": [
    "src",
    "tests",
    "vite.config.ts"
  ]
}
</file>

<file path="vitest.config.ts">
import { defineConfig } from 'vitest/config';
import { fileURLToPath } from 'node:url';
import path from 'node:path';

const resolveFromRoot = (relativePath: string): string => {
    const rootDir = path.dirname(fileURLToPath(import.meta.url));
    return path.resolve(rootDir, relativePath);
};

export default defineConfig({
    resolve: {
        alias: {
            'app': resolveFromRoot('src/app'),
            'physics': resolveFromRoot('src/physics'),
            'render': resolveFromRoot('src/render'),
            'audio': resolveFromRoot('src/audio'),
            'util': resolveFromRoot('src/util'),
            'cli': resolveFromRoot('src/cli'),
            'input': resolveFromRoot('src/input'),
            'types': resolveFromRoot('src/types'),
        },
    },
    test: {
        environment: 'jsdom',
        include: ['tests/unit/**/*.spec.ts'],
        setupFiles: ['tests/setup/vitest.setup.ts'],
        clearMocks: true,
        coverage: {
            provider: 'v8',
            reporter: ['text', 'html'],
            include: ['src/**/*.{ts,tsx}'],
        },
    },
});
</file>

<file path="src/physics/world.ts">
import { Bodies, Body, Composite, Constraint, Engine, World, type Vector } from 'matter-js';
import type { Vector2, BallAttachment } from '../types';

const DEFAULT_TIMESTEP_MS = 1000 / 120;
const DEFAULT_WIDTH = 800;
const DEFAULT_HEIGHT = 600;
const DEFAULT_WALL_THICKNESS = 32;

export interface PhysicsWorldDimensions {
    readonly width: number;
    readonly height: number;
    readonly wallThickness?: number;
}

export interface PhysicsWorldConfig {
    readonly gravity?: number;
    readonly timeStepMs?: number;
    readonly enableSleeping?: boolean;
    readonly dimensions?: PhysicsWorldDimensions;
}

export interface BallFactoryOptions {
    readonly radius: number;
    readonly position?: Vector;
    readonly restitution?: number;
    readonly label?: string;
    readonly velocity?: Vector;
}

export interface PaddleFactoryOptions {
    readonly size: { readonly width: number; readonly height: number };
    readonly position: Vector;
    readonly label?: string;
}

export interface BrickFactoryOptions {
    readonly size: { readonly width: number; readonly height: number };
    readonly position: Vector;
    readonly label?: string;
    readonly isSensor?: boolean;
}

export interface PhysicsFactories {
    readonly ball: (options: BallFactoryOptions) => Body;
    readonly paddle: (options: PaddleFactoryOptions) => Body;
    readonly brick: (options: BrickFactoryOptions) => Body;
    readonly bounds: () => Body[];
}

export interface PhysicsWorldHandle {
    readonly engine: Engine;
    readonly world: World;
    readonly step: (deltaMs?: number) => void;
    readonly add: (body: Body | readonly Body[]) => void;
    readonly remove: (body: Body | readonly Body[]) => void;
    readonly factory: PhysicsFactories;
    readonly dispose: () => void;
    // Ball attachment tracking
    readonly attachBallToPaddle: (ball: Body, paddle: Body, offset?: Vector2) => void;
    readonly detachBallFromPaddle: (ball: Body) => void;
    readonly updateBallAttachment: (ball: Body, paddlePosition: Vector2) => void;
    readonly isBallAttached: (ball: Body) => boolean;
    readonly getBallAttachment: (ball: Body) => BallAttachment | null;
}

const withDefaultVector = (vector: Vector | undefined, fallback: Vector): Vector => vector ?? fallback;

const toBodyArray = (input: Body | readonly Body[]): Body[] => {
    if (Array.isArray(input)) {
        return [...input];
    }

    return [input as Body];
};

const configureGravity = (engine: Engine, gravity?: number): void => {
    engine.world.gravity.x = 0;
    engine.world.gravity.y = gravity ?? 1;
    engine.world.gravity.scale = 0.001;
    engine.world.damping = 0; // No velocity damping
};

const createFactories = (_world: World, dimensions: PhysicsWorldDimensions): PhysicsFactories => {
    const wallThickness = dimensions.wallThickness ?? DEFAULT_WALL_THICKNESS;
    const halfWidth = dimensions.width / 2;
    const halfHeight = dimensions.height / 2;

    const ball: PhysicsFactories['ball'] = (options) => {
        const position = withDefaultVector(options.position, { x: halfWidth, y: halfHeight });
        const body = Bodies.circle(position.x, position.y, options.radius, {
            restitution: options.restitution ?? 1, // Perfect energy-preserving bounces
            friction: 0,
            frictionAir: 0,  // Remove air resistance for consistent ball speed
            label: options.label ?? 'ball',
        });

        body.damping = 0;  // No velocity damping

        if (options.velocity) {
            Body.setVelocity(body, options.velocity);
        }

        return body;
    };

    const paddle: PhysicsFactories['paddle'] = (options) => {
        const body = Bodies.rectangle(options.position.x, options.position.y, options.size.width, options.size.height, {
            label: options.label ?? 'paddle',
            inertia: Infinity,
            friction: 0,
            frictionStatic: 0,
            frictionAir: 0,
            restitution: 1,
            isStatic: true,
        });

        return body;
    };

    const brick: PhysicsFactories['brick'] = (options) =>
        Bodies.rectangle(options.position.x, options.position.y, options.size.width, options.size.height, {
            label: options.label ?? 'brick',
            restitution: 1,
            friction: 0,
            frictionStatic: 0,
            isStatic: true,
            isSensor: options.isSensor ?? false,
        });

    const bounds: PhysicsFactories['bounds'] = () => {
        const horizontalWidth = dimensions.width + wallThickness * 2;
        const verticalHeight = dimensions.height + wallThickness * 2;
        const top = Bodies.rectangle(halfWidth, -wallThickness / 2, horizontalWidth, wallThickness, {
            label: 'wall-top',
            isStatic: true,
            restitution: 1,
        });
        const right = Bodies.rectangle(dimensions.width + wallThickness / 2, halfHeight, wallThickness, verticalHeight, {
            label: 'wall-right',
            isStatic: true,
            restitution: 1,
        });
        const bottom = Bodies.rectangle(halfWidth, dimensions.height + wallThickness / 2, horizontalWidth, wallThickness, {
            label: 'wall-bottom',
            isStatic: true,
            restitution: 1,
        });
        const left = Bodies.rectangle(-wallThickness / 2, halfHeight, wallThickness, verticalHeight, {
            label: 'wall-left',
            isStatic: true,
            restitution: 1,
        });

        return [top, right, bottom, left];
    };

    return {
        ball,
        paddle,
        brick,
        bounds,
    };
};

export const createPhysicsWorld = (config: PhysicsWorldConfig = {}): PhysicsWorldHandle => {
    const dimensions: PhysicsWorldDimensions = config.dimensions ?? {
        width: DEFAULT_WIDTH,
        height: DEFAULT_HEIGHT,
    };

    const engine = Engine.create({
        enableSleeping: config.enableSleeping ?? false,
        constraintIterations: 4,
        velocityIterations: 8,
        positionIterations: 8, // Increased for better collision accuracy and prevent tunneling
    });
    configureGravity(engine, config.gravity);
    const timeStep = config.timeStepMs ?? DEFAULT_TIMESTEP_MS;

    // Set world bounds to prevent tunneling
    engine.world.bounds = {
        min: { x: 0, y: 0 },
        max: { x: dimensions.width, y: dimensions.height },
    };

    // Ball attachment tracking
    const ballAttachments = new Map<number, BallAttachment>();

    const attachBallToPaddle: PhysicsWorldHandle['attachBallToPaddle'] = (ball, paddle, offset = { x: 0, y: -ball.circleRadius! - paddle.circleRadius! }) => {
        ballAttachments.set(ball.id, {
            isAttached: true,
            attachmentOffset: offset,
            paddlePosition: { x: paddle.position.x, y: paddle.position.y },
        });

        // Set ball velocity to zero and position it relative to paddle
        Body.setVelocity(ball, { x: 0, y: 0 });
        Body.setPosition(ball, {
            x: paddle.position.x + offset.x,
            y: paddle.position.y + offset.y,
        });
    };

    const detachBallFromPaddle: PhysicsWorldHandle['detachBallFromPaddle'] = (ball) => {
        ballAttachments.delete(ball.id);
    };

    const updateBallAttachment: PhysicsWorldHandle['updateBallAttachment'] = (ball, paddlePosition) => {
        const attachment = ballAttachments.get(ball.id);
        if (attachment && attachment.isAttached) {
            attachment.paddlePosition = paddlePosition;
            Body.setPosition(ball, {
                x: paddlePosition.x + attachment.attachmentOffset.x,
                y: paddlePosition.y + attachment.attachmentOffset.y,
            });
            Body.setVelocity(ball, { x: 0, y: 0 });
        }
    };

    const isBallAttached: PhysicsWorldHandle['isBallAttached'] = (ball) => {
        const attachment = ballAttachments.get(ball.id);
        return attachment?.isAttached ?? false;
    };

    const getBallAttachment: PhysicsWorldHandle['getBallAttachment'] = (ball) => {
        return ballAttachments.get(ball.id) ?? null;
    };

    const add: PhysicsWorldHandle['add'] = (bodyOrBodies) => {
        toBodyArray(bodyOrBodies).forEach((body) => {
            Composite.add(engine.world, body);
        });
    };

    const remove: PhysicsWorldHandle['remove'] = (bodyOrBodies) => {
        toBodyArray(bodyOrBodies).forEach((body) => {
            Composite.remove(engine.world, body);
        });
    };

    const step: PhysicsWorldHandle['step'] = (deltaMs = timeStep) => {
        // Update ball attachments before stepping physics
        ballAttachments.forEach((attachment, ballId) => {
            if (attachment.isAttached) {
                const ball = Composite.get(engine.world, ballId, 'body') as Body;
                if (ball) {
                    Body.setPosition(ball, {
                        x: attachment.paddlePosition.x + attachment.attachmentOffset.x,
                        y: attachment.paddlePosition.y + attachment.attachmentOffset.y,
                    });
                    Body.setVelocity(ball, { x: 0, y: 0 });
                    // Clear any forces that may have been applied
                    Body.setVelocity(ball, { x: 0, y: 0 });
                    if (ball.force) {
                        ball.force.x = 0;
                        ball.force.y = 0;
                    }
                }
            }
        });

        Engine.update(engine, deltaMs);
    };

    const dispose: PhysicsWorldHandle['dispose'] = () => {
        Composite.clear(engine.world, false);
        Engine.clear(engine);
    };

    return {
        engine,
        world: engine.world,
        add,
        remove,
        step,
        factory: createFactories(engine.world, dimensions),
        dispose,
        attachBallToPaddle,
        detachBallFromPaddle,
        updateBallAttachment,
        isBallAttached,
        getBallAttachment,
    };
};
</file>

<file path="src/app/main.ts">
import { createPreloader } from './preloader';
import { createStage } from 'render/stage';
import { createPhysicsWorld } from 'physics/world';
import { createGameLoop } from './loop';
import { createGameSessionManager } from './state';
import { buildHudScoreboard } from 'render/hud';
import { BallAttachmentController } from 'physics/ball-attachment';
import { PaddleBodyController } from 'render/paddle-body';
import { GameInputManager } from 'input/input-manager';
import { PhysicsBallLaunchController } from 'physics/ball-launch';
import { reflectOffPaddle } from 'util/paddle-reflection';
import { regulateSpeed } from 'util/speed-regulation';
import { createScoring, awardBrickPoints, decayCombo } from 'util/scoring';
import { PowerUpManager, shouldSpawnPowerUp, selectRandomPowerUpType, calculatePaddleWidthScale } from 'util/power-ups';
import { generateLevelLayout, getLevelSpec } from 'util/levels';
import { Text, Container, Graphics, Sprite } from 'pixi.js';
import type { Body } from 'matter-js';
import { Events, Body as MatterBody } from 'matter-js';
import { createEventBus } from 'app/events';
import { createToneScheduler } from 'audio/scheduler';
import { createSfxRouter } from 'audio/sfx';
import { Synth, Panner, start as toneStart } from 'tone';

export interface LuckyBreakOptions {
    readonly container?: HTMLElement;
}

export function bootstrapLuckyBreak(options: LuckyBreakOptions = {}): void {
    const container = options.container ?? document.body;

    const preloader = createPreloader({
        container,
        onStart: async () => {
            // Initialize the game components
            const stage = await createStage({ parent: container });

            // Set canvas to fill viewport
            stage.canvas.style.width = '100vw';
            stage.canvas.style.height = '100vh';
            stage.canvas.style.position = 'absolute';
            stage.canvas.style.top = '0';
            stage.canvas.style.left = '0';

            await toneStart();  // Start Tone.js audio context (call once)

            const bus = createEventBus();  // Create event bus

            const scheduler = createToneScheduler({ lookAheadMs: 120 });

            const panner = new Panner(0).toDestination();
            const synth = new Synth().connect(panner);

            const router = createSfxRouter({
                bus,
                scheduler,
                brickSampleId: 'brick-hit',  // Placeholder ID
                trigger: (descriptor) => {
                    // Play sound based on descriptor (e.g., pan/detune from brick hit)
                    synth.triggerAttackRelease(
                        'C4',  // Note (tune based on detune)
                        '8n',  // Duration
                        descriptor.time,
                        descriptor.gain
                    );
                    panner.pan.setValueAtTime(descriptor.pan, descriptor.time);
                    synth.detune.setValueAtTime(descriptor.detune, descriptor.time);
                },
            });

            // Add resize listener
            const handleResize = () => {
                const w = window.innerWidth;
                const h = window.innerHeight;
                stage.resize({ width: w, height: h });

                // Change to stretch-fill instead of aspect-preserved scale
                const scaleX = w / 1280;
                const scaleY = h / 720;
                stage.layers.root.scale.set(scaleX, scaleY);
                stage.layers.root.position.set(0, 0);  // No centering—fill from top-left
            };
            window.addEventListener('resize', handleResize);
            handleResize();  // Initial resize
            // Create physics world
            const physics = createPhysicsWorld({
                dimensions: { width: 1280, height: 720 },
                gravity: 0
            });

            // Create game session manager
            const session = createGameSessionManager({
                sessionId: 'game-session',
                initialLives: 3
            });

            // Create scoring and power-up systems
            const scoringState = createScoring();
            const powerUpManager = new PowerUpManager();
            let currentLevelIndex = 0;

            // Game configuration
            const BALL_BASE_SPEED = 8;
            const BALL_MAX_SPEED = 14;
            const BRICK_WIDTH = 100;
            const BRICK_HEIGHT = 40;

            // Function to load a level
            const loadLevel = (levelIndex: number) => {
                // Clear existing bricks
                visualBodies.forEach((visual, body) => {
                    if (body.label === 'brick') {
                        physics.remove(body);
                        stage.removeFromLayer(visual);
                        visualBodies.delete(body);
                    }
                });

                // Generate new level layout
                const layout = generateLevelLayout(getLevelSpec(levelIndex), BRICK_WIDTH, BRICK_HEIGHT, 1280);

                // Create bricks from layout
                layout.bricks.forEach(brickSpec => {
                    const brick = physics.factory.brick({
                        size: { width: BRICK_WIDTH, height: BRICK_HEIGHT },
                        position: { x: brickSpec.x, y: brickSpec.y },
                    });
                    physics.add(brick);

                    // Add visual brick with color based on HP
                    const color = brickSpec.hp === 1 ? 0xaaaaaa : brickSpec.hp === 2 ? 0xff8844 : 0xff4444;
                    const brickVisual = new Graphics()
                        .beginFill(color)
                        .drawRect(-BRICK_WIDTH / 2, -BRICK_HEIGHT / 2, BRICK_WIDTH, BRICK_HEIGHT)
                        .endFill();
                    brickVisual.position.set(brickSpec.x, brickSpec.y);
                    visualBodies.set(brick, brickVisual);
                    stage.layers.playfield.addChild(brickVisual);
                });

                // Start the round
                session.startRound({ breakableBricks: layout.breakableCount });
            };

            // Add collision event handling
            Events.on(physics.engine, 'collisionStart', (event) => {
                event.pairs.forEach((pair) => {
                    const { bodyA, bodyB } = pair;

                    // Brick break
                    if ((bodyA.label === 'ball' && bodyB.label === 'brick') || (bodyA.label === 'brick' && bodyB.label === 'ball')) {
                        const brick = bodyA.label === 'brick' ? bodyA : bodyB;
                        const ballBody = bodyA.label === 'ball' ? bodyA : bodyB;

                        bus.publish('BrickBreak', {
                            sessionId: session.snapshot().sessionId,
                            row: Math.floor((brick.position.y - 100) / BRICK_HEIGHT),  // Estimate row/col from position
                            col: Math.floor((brick.position.x - 50) / BRICK_WIDTH),
                            velocity: ball.physicsBody.speed,  // From ball
                            comboHeat: scoringState.combo,
                            brickType: 'standard', //TODO: This should be dynamic
                        });

                        // Award points with combo system
                        const points = awardBrickPoints(scoringState);
                        session.recordBrickBreak({ points });

                        // Check for power-up spawn
                        if (shouldSpawnPowerUp({ spawnChance: 0.25 })) {
                            const powerUpType = selectRandomPowerUpType();
                            powerUpManager.activate(powerUpType, { defaultDuration: 2.5 });
                            console.log(`Power-up activated: ${powerUpType}`);
                        }

                        // Remove brick
                        physics.remove(brick);
                        const visual = visualBodies.get(brick);
                        if (visual) {
                            stage.removeFromLayer(visual);
                            visualBodies.delete(brick);
                        }

                        // Check win condition
                        if (session.snapshot().brickRemaining === 0) {
                            session.completeRound();
                            setTimeout(() => {
                                currentLevelIndex += 1;
                                loadLevel(currentLevelIndex);
                            }, 500);
                        }
                    }

                    // Paddle-ball collision with advanced reflection
                    if ((bodyA.label === 'ball' && bodyB.label === 'paddle') || (bodyA.label === 'paddle' && bodyB.label === 'ball')) {
                        const ballBody = bodyA.label === 'ball' ? bodyA : bodyB;
                        const paddleBody = bodyA.label === 'paddle' ? bodyA : bodyB;

                        // Apply paddle reflection
                        reflectOffPaddle(ballBody, paddleBody, {
                            paddleWidth: paddle.width,
                            minSpeed: BALL_BASE_SPEED,
                        });
                    }

                    // Ball hitting bottom (lose life)
                    if ((bodyA.label === 'ball' && bodyB.label === 'wall-bottom') || (bodyA.label === 'wall-bottom' && bodyB.label === 'ball')) {
                        const ballBody = bodyA.label === 'ball' ? bodyA : bodyB;

                        // Lose a life and reset combo
                        session.recordLifeLost('ball-drop');
                        scoringState.combo = 0;
                        scoringState.comboTimer = 0;

                        if (session.snapshot().livesRemaining > 0) {
                            // Reset ball to paddle
                            physics.attachBallToPaddle(ball.physicsBody, paddle.physicsBody);
                        } else {
                            // Game over
                            console.log('Game Over - Final Score:', scoringState.score);
                        }
                    }
                });
            });

            // Create HUD container
            const hudContainer = new Container();
            stage.layers.root.addChild(hudContainer);

            // Create game objects container
            const gameContainer = new Container();
            stage.addToLayer('playfield', gameContainer);

            // Create visual representations for physics objects
            const visualBodies = new Map<Body, Container>();

            // Add some initial game objects for testing
            const bounds = physics.factory.bounds();
            physics.add(bounds);

            // Create visual bounds (walls)
            bounds.forEach(bound => {
                const graphics = new Graphics();
                graphics.rect(bound.position.x - bound.bounds.max.x + bound.bounds.min.x,
                    bound.position.y - bound.bounds.max.y + bound.bounds.min.y,
                    bound.bounds.max.x - bound.bounds.min.x,
                    bound.bounds.max.y - bound.bounds.min.y);
                graphics.fill({ color: 0x444444 });
                gameContainer.addChild(graphics);
                visualBodies.set(bound, graphics);
            });

            // Create controllers
            const ballController = new BallAttachmentController();
            const paddleController = new PaddleBodyController();
            const inputManager = new GameInputManager();
            const launchController = new PhysicsBallLaunchController();

            // Create paddle first at center bottom
            const paddle = paddleController.createPaddle(
                { x: 640, y: 650 },
                { width: 100, height: 20, speed: 300 }
            );
            physics.add(paddle.physicsBody);

            // Create ball attached to paddle
            const ball = ballController.createAttachedBall(
                paddleController.getPaddleCenter(paddle),
                { radius: 10, restitution: 0.98 }
            );
            physics.add(ball.physicsBody);

            // Create visual ball
            const ballGraphics = new Graphics();
            ballGraphics.circle(0, 0, ball.radius);
            ballGraphics.fill({ color: 0xff0000 });
            gameContainer.addChild(ballGraphics);
            visualBodies.set(ball.physicsBody, ballGraphics);

            // Create visual paddle
            const paddleGraphics = new Graphics();
            paddleGraphics.rect(-paddle.width / 2, -paddle.height / 2, paddle.width, paddle.height);
            paddleGraphics.fill({ color: 0x00ff00 });
            gameContainer.addChild(paddleGraphics);
            visualBodies.set(paddle.physicsBody, paddleGraphics);

            // Load initial level
            loadLevel(currentLevelIndex);

            // Initialize input manager AFTER preloader completes to avoid capturing the "Tap to Start" click
            inputManager.initialize(container);

            // Helper to convert canvas coordinates to playfield (1280×720) coordinates
            const toPlayfield = (canvasPt: { x: number; y: number }) => {
                const root = stage.layers.root;
                const s = root.scale.x; // uniform scale
                return {
                    x: (canvasPt.x - root.position.x) / s,
                    y: (canvasPt.y - root.position.y) / s,
                };
            };

            const loop = createGameLoop({
                world: physics,
                stage,
                hooks: {
                    beforeStep: (deltaMs) => {
                        const deltaSeconds = deltaMs / 1000;

                        // Update power-ups
                        powerUpManager.update(deltaSeconds);

                        // Update paddle size based on power-ups
                        const paddleScale = calculatePaddleWidthScale(
                            powerUpManager.getEffect('paddle-width'),
                            { paddleWidthMultiplier: 1.5 }
                        );
                        const basePaddleWidth = 100;
                        paddle.width = basePaddleWidth * paddleScale;

                        // Update paddle visual
                        paddleGraphics.clear();
                        paddleGraphics.rect(-paddle.width / 2, -paddle.height / 2, paddle.width, paddle.height);
                        const paddleColor = powerUpManager.isActive('paddle-width') ? 0xffff66 : 0x00ff00;
                        paddleGraphics.fill({ color: paddleColor });

                        // Decay combo timer
                        decayCombo(scoringState, deltaSeconds);

                        // Process input
                        const paddleTarget = inputManager.getPaddleTarget();
                        if (paddleTarget) {
                            const rect = stage.canvas.getBoundingClientRect();  // Ensure relative to canvas
                            const canvasX = paddleTarget.x - rect.left;  // Explicitly correct for any offset
                            const canvasY = paddleTarget.y - rect.top;

                            const pf = toPlayfield({ x: canvasX, y: canvasY });  // Use corrected canvas coords

                            const targetX = pf.x;
                            const halfPaddleWidth = paddle.width / 2;
                            const clampedX = Math.max(halfPaddleWidth, Math.min(targetX, 1280 - halfPaddleWidth));
                            MatterBody.setPosition(paddle.physicsBody, { x: clampedX, y: paddle.physicsBody.position.y });
                        }

                        // Update ball attachment to follow paddle
                        ballController.updateAttachment(ball, paddleController.getPaddleCenter(paddle));

                        // Check for launch triggers
                        if (inputManager.shouldLaunch() ||
                            inputManager.checkMovementLaunch(paddleController.getPaddleCenter(paddle))) {
                            physics.detachBallFromPaddle(ball.physicsBody);
                            launchController.launch(ball);
                            inputManager.resetLaunchTrigger();
                        }
                    },
                    afterStep: () => {
                        // Regulate ball speed
                        regulateSpeed(ball.physicsBody, {
                            baseSpeed: BALL_BASE_SPEED,
                            maxSpeed: BALL_MAX_SPEED,
                        });

                        // Update visual positions to match physics bodies
                        visualBodies.forEach((visual, body) => {
                            visual.x = body.position.x;
                            visual.y = body.position.y;
                            visual.rotation = body.angle;
                        });
                    },
                    afterRender: () => {
                        // Update HUD
                        const snapshot = session.snapshot();
                        const hudView = buildHudScoreboard(snapshot);

                        // Clear existing HUD
                        hudContainer.removeChildren();

                        // Add status text
                        const statusText = new Text({
                            text: hudView.statusText,
                            style: { fill: 0xffffff, fontSize: 16 }
                        });
                        statusText.x = 20;
                        statusText.y = 20;
                        hudContainer.addChild(statusText);

                        // Add summary
                        if (hudView.summaryLine) {
                            const summaryText = new Text({
                                text: hudView.summaryLine,
                                style: { fill: 0xcccccc, fontSize: 14 }
                            });
                            summaryText.x = 20;
                            summaryText.y = 50;
                            hudContainer.addChild(summaryText);
                        }

                        // Add scoreboard entries
                        hudView.entries.forEach((entry, index) => {
                            const entryText = new Text({
                                text: `${entry.label}: ${entry.value}`,
                                style: { fill: 0xffffff, fontSize: 12 }
                            });
                            entryText.x = 20;
                            entryText.y = 80 + index * 20;
                            hudContainer.addChild(entryText);
                        });

                        // Add combo info
                        if (scoringState.combo > 0) {
                            const comboText = new Text({
                                text: `Combo: ${scoringState.combo}x (${scoringState.comboTimer.toFixed(1)}s)`,
                                style: { fill: 0xffff00, fontSize: 14, fontWeight: 'bold' }
                            });
                            comboText.x = 20;
                            comboText.y = 80 + hudView.entries.length * 20 + 10;
                            hudContainer.addChild(comboText);
                        }

                        // Add active power-ups
                        const activePowerUps = powerUpManager.getActiveEffects();
                        activePowerUps.forEach((effect, index) => {
                            const powerUpText = new Text({
                                text: `${effect.type}: ${effect.remainingTime.toFixed(1)}s`,
                                style: { fill: 0x00ffff, fontSize: 12 }
                            });
                            powerUpText.x = 20;
                            powerUpText.y = 80 + hudView.entries.length * 20 + 35 + index * 18;
                            hudContainer.addChild(powerUpText);
                        });
                    }
                }
            });

            // Start the game loop
            loop.start();

            // Add dispose on unload (optional):
            window.addEventListener('beforeunload', () => {
                router.dispose();
                scheduler.dispose();
            });
        }
    });

    preloader.prepare().catch(console.error);
}

const container = document.getElementById('app');
if (container) {
    bootstrapLuckyBreak({ container });
}
</file>

</files>
